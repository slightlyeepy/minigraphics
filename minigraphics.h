/*
 * minigraphics in-development (versioned releases will come later)
 * NOTE: until versioned releases come, breaking API changes may happen
 * at any time without notice.
 *
 * ===========================================================================
 * LICENSE
 *
 * your choice between Unlicense and MIT/X Consortium.
 * see the end of the file for license information.
 *
 * ===========================================================================
 * USAGE
 *
 * use as a standard single-header library.
 * make sure to read the "BACKEND-SPECIFIC INSTRUCTIONS" section below.
 *
 * you can `#define` these before including the header or pass them with `-D`:
 *      +----------------------+---------------------------------------------+
 *      | MG_IMPLEMENTATION    | enable the implementation                   |
 *      +----------------------+---------------------------------------------+
 *      | MG_BACKEND_X11       | (impl.) enable the X11 backend              |
 *      +----------------------+---------------------------------------------+
 *      | MG_BACKEND_WAYLAND   | (impl.) enable the Wayland backend          |
 *      +----------------------+---------------------------------------------+
 *      | MG_API               | how public API functions will be decorated  |
 *      |                      | default: `extern`                           |
 *      +----------------------+---------------------------------------------+
 *      | MG_UNUSED            | (impl.) how unused fields will be marked    |
 *      |                      | default: `__attribute__((__unused__))` if   |
 *      |                      | `__GNUC__` is defined, `` otherwise         |
 *      +----------------------+---------------------------------------------+
 *
 * if you don't like the single-header format, you can create a file
 * `minigraphics.c` with the contents:
 * 	#define MG_IMPLEMENTATION
 * 	#include "minigraphics.h"
 * and use `minigraphics.{c,h}` as a standard source/header pair.
 *
 * note that a global variable 'mg' for internal library state and other
 * internal identifiers beginning with 'mg__' or 'MG__' are used in the
 * implementation; be careful using them in the file that provides it.
 *
 * see the "DOCS" section for the API documentation.
 * see the examples directory for example programs.
 *
 * ===========================================================================
 * BACKEND-SPECIFIC INSTRUCTIONS
 *
 * X11
 * --------------------------
 * link with `-lrt -lX11`.
 * `-lrt` may be unnecessary depending on your libc.
 *
 * example compiler command:
 * ```
 * cc -lrt -lX11 -DMG_BACKEND_X11 -o program program.c
 * ```
 *
 * WAYLAND
 * --------------------------
 * link with `-lrt -lwayland-client -lxkbcommon`.
 * `-lrt` may be unnecessary depending on your libc.
 *
 * additionally,
 * you'll need `xdg-shell-client-protocol.h` in your include paths,
 * and you'll need to add `xdg-shell-protocol.c` to your sources.
 *
 * to generate these files, make sure you have `wayland-protocols` and
 * `wayland-scanner` (typically provided by a package named `wayland` or
 * `wayland-devel`) installed and then run:
 *
 * ```
 * wayland-scanner private-code \
 * 	< /usr/share/wayland-protocols/stable/xdg-shell/xdg-shell.xml \
 * 	> xdg-shell-protocol.c
 *
 * wayland-scanner client-header \
 * 	< /usr/share/wayland-protocols/stable/xdg-shell/xdg-shell.xml \
 * 	> xdg-shell-client-protocol.h
 * ```
 *
 * note that `xdg-shell.xml` may be located somewhere else on your system.
 *
 * example compiler command:
 * ```
 * cc -lrt -lwayland-client -lxkbcommon -DMG_BACKEND_WAYLAND -I. \
 * 	-o program xdg-shell-protocol.c program.c
 * ```
 */
#if !defined(MG_H)
#define MG_H
#include <setjmp.h>
#include <stdint.h>

#if !defined(MG_API)
#define MG_API extern
#endif /* !defined(MG_API) */

#if !defined(MG_UNUSED)

#if defined(__GNUC__)
#define MG_UNUSED __attribute__((__unused__))
#else
#define MG_UNUSED
#endif /* defined(__GNUC__) */

#endif /* !defined(MG_UNUSED) */

/*
 * ===========================================================================
 * DOCS (+ header)
 *
 * these global variables hold the current window dimensions and are updated
 * automatically whenever it is resized.
 */
extern int mg_width;
extern int mg_height;

/* these are all of the errors that can be generated by this library. */
enum mg_error {
	/* possible on both backends */
	MG_CONNECTION_FAILED,
	MG_OUT_OF_MEMORY,
	MG_IO_ERROR,                /* sets mg_storederrno */
	MG_KEYBOARD_SETUP_FAILED,

	/* possible on X11 */
	MG_X11_UNSUPPORTED_COLOR_DEPTH,

	/* possible on Wayland */
	MG_WL_UNSUPPORTED_KEYMAP,
	MG_WL_PROTOCOL_OR_IO_ERROR, /* sets mg_storederrno */
	MG_WL_SHM_ERROR             /* sets mg_storederrno */
};

/*
 * `mg_errstatus` holds the error type if the library encounters an error
 * for more info on library errors, see below, at mg_init()
 *
 * if that error was from something that also sets `errno`, that
 * `errno` value gets stored in `mg_storederrno`
 */
extern enum mg_error mg_errstatus;
extern int mg_storederrno;

/*
 * minigraphics uses an event loop for handling of things such as
 * key presses, mouse clicks/movement, etc.
 * these are all of the possible events that can be recieved.
 */
enum mg_event_type {
	MG_QUIT             = 1, /* user has requested to close the window */
	MG_RESIZE      = 1 << 1, /* window has been resized & needs redraw */
	MG_REDRAW      = 1 << 2, /* window should be redrawn */
	MG_KEYDOWN     = 1 << 3, /* key on the keyboard has been pressed */
	MG_KEYUP       = 1 << 4, /* key on the keyboard has been unpressed */
	MG_MOUSEDOWN   = 1 << 5, /* button on the mouse has been pressed */
	MG_MOUSEUP     = 1 << 6, /* button on the mouse has been unpressed */
	MG_MOUSEMOTION = 1 << 7, /* the mouse has moved */
};

/*
 * keyboard keys are represented with values based on USB HID
 * Usage Page 0x07 codes.
 * https://www.usb.org/sites/default/files/documents/hut1_12v2.pdf
 * starts at page 53
 *
 * these share names with SDL, simply replace `SDL_SCANCODE_` with `MG_KEY_`.
 * to skip over this, jump to line 413
 */
enum mg_key {
	MG_KEY_UNKNOWN            = 0x00,
	/*
	 * in Usage Page 0x07:
	 * 0x01 = keyboard ErrorRollOver
	 * 0x02 = keyboard POSTFail
	 * 0x03 = keyboard ErrorUndefined
	 * these are hardware errors, not actual keys, we don't need these
	 */

	MG_KEY_A                  = 0x04,
	MG_KEY_B                  = 0x05,
	MG_KEY_C                  = 0x06,
	MG_KEY_D                  = 0x07,
	MG_KEY_E                  = 0x08,
	MG_KEY_F                  = 0x09,
	MG_KEY_G                  = 0x0a,
	MG_KEY_H                  = 0x0b,
	MG_KEY_I                  = 0x0c,
	MG_KEY_J                  = 0x0d,
	MG_KEY_K                  = 0x0e,
	MG_KEY_L                  = 0x0f,
	MG_KEY_M                  = 0x10,
	MG_KEY_N                  = 0x11,
	MG_KEY_O                  = 0x12,
	MG_KEY_P                  = 0x13,
	MG_KEY_Q                  = 0x14,
	MG_KEY_R                  = 0x15,
	MG_KEY_S                  = 0x16,
	MG_KEY_T                  = 0x17,
	MG_KEY_U                  = 0x18,
	MG_KEY_V                  = 0x19,
	MG_KEY_W                  = 0x1a,
	MG_KEY_X                  = 0x1b,
	MG_KEY_Y                  = 0x1c,
	MG_KEY_Z                  = 0x1d,

	MG_KEY_1                  = 0x1e,
	MG_KEY_2                  = 0x1f,
	MG_KEY_3                  = 0x20,
	MG_KEY_4                  = 0x21,
	MG_KEY_5                  = 0x22,
	MG_KEY_6                  = 0x23,
	MG_KEY_7                  = 0x24,
	MG_KEY_8                  = 0x25,
	MG_KEY_9                  = 0x26,
	MG_KEY_0                  = 0x27,

	MG_KEY_RETURN             = 0x28,
	MG_KEY_ESCAPE             = 0x29,
	MG_KEY_BACKSPACE          = 0x2a,
	MG_KEY_TAB                = 0x2b,
	MG_KEY_SPACE              = 0x2c,

	MG_KEY_MINUS              = 0x2d,
	MG_KEY_EQUALS             = 0x2e,
	MG_KEY_LEFTBRACKET        = 0x2f,
	MG_KEY_RIGHTBRACKET       = 0x30,
	MG_KEY_BACKSLASH          = 0x31,
	/* !! BACKSLASH is almost always generated instead of NONUSHASH !! */
	MG_KEY_NONUSHASH          = 0x32,
	MG_KEY_SEMICOLON          = 0x33,
	MG_KEY_APOSTROPHE         = 0x34,
	MG_KEY_GRAVE              = 0x35,
	MG_KEY_COMMA              = 0x36,
	MG_KEY_PERIOD             = 0x37,
	MG_KEY_SLASH              = 0x38,

	MG_KEY_CAPSLOCK           = 0x39,

	MG_KEY_F1                 = 0x3a,
	MG_KEY_F2                 = 0x3b,
	MG_KEY_F3                 = 0x3c,
	MG_KEY_F4                 = 0x3d,
	MG_KEY_F5                 = 0x3e,
	MG_KEY_F6                 = 0x3f,
	MG_KEY_F7                 = 0x40,
	MG_KEY_F8                 = 0x41,
	MG_KEY_F9                 = 0x42,
	MG_KEY_F10                = 0x43,
	MG_KEY_F11                = 0x44,
	MG_KEY_F12                = 0x45,

	MG_KEY_PRINTSCREEN        = 0x46,
	MG_KEY_SCROLLLOCK         = 0x47,
	MG_KEY_PAUSE              = 0x48,
	MG_KEY_INSERT             = 0x49,
	MG_KEY_HOME               = 0x4a,
	MG_KEY_PAGEUP             = 0x4b,
	MG_KEY_DELETE             = 0x4c,
	MG_KEY_END                = 0x4d,
	MG_KEY_PAGEDOWN           = 0x4e,
	MG_KEY_RIGHT              = 0x4f,
	MG_KEY_LEFT               = 0x50,
	MG_KEY_DOWN               = 0x51,
	MG_KEY_UP                 = 0x52,

	MG_KEY_NUMLOCKCLEAR       = 0x53, /* numlk on pc, clear on mac */
	MG_KEY_KP_DIVIDE          = 0x54,
	MG_KEY_KP_MULTIPLY        = 0x55,
	MG_KEY_KP_MINUS           = 0x56,
	MG_KEY_KP_PLUS            = 0x57,
	MG_KEY_KP_ENTER           = 0x58,
	MG_KEY_KP_1               = 0x59, /* or end */
	MG_KEY_KP_2               = 0x5a, /* or down */
	MG_KEY_KP_3               = 0x5b, /* or pgdn */
	MG_KEY_KP_4               = 0x5c, /* or left */
	MG_KEY_KP_5               = 0x5d,
	MG_KEY_KP_6               = 0x5e, /* or right */
	MG_KEY_KP_7               = 0x5f, /* or home */
	MG_KEY_KP_8               = 0x60, /* or up */
	MG_KEY_KP_9               = 0x61, /* or pgup */
	MG_KEY_KP_0               = 0x62, /* or ins */
	MG_KEY_KP_PERIOD          = 0x63, /* or del */

	MG_KEY_NONUSBACKSLASH     = 0x64,
	MG_KEY_APPLICATION        = 0x65, /* menu/context, compose */
	MG_KEY_POWER              = 0x66,
	MG_KEY_KP_EQUALS          = 0x67,
	MG_KEY_F13                = 0x68,
	MG_KEY_F14                = 0x69,
	MG_KEY_F15                = 0x6a,
	MG_KEY_F16                = 0x6b,
	MG_KEY_F17                = 0x6c,
	MG_KEY_F18                = 0x6d,
	MG_KEY_F19                = 0x6e,
	MG_KEY_F20                = 0x6f,
	MG_KEY_F21                = 0x70,
	MG_KEY_F22                = 0x71,
	MG_KEY_F23                = 0x72,
	MG_KEY_F24                = 0x73,

	/* !! all of these are never generated on X11 & Wayland !! */
	MG_KEY_EXECUTE            = 0x74,
	MG_KEY_HELP               = 0x75,
	MG_KEY_MENU               = 0x76,
	MG_KEY_SELECT             = 0x77,
	MG_KEY_STOP               = 0x78,
	MG_KEY_AGAIN              = 0x79,
	MG_KEY_UNDO               = 0x7a,
	MG_KEY_CUT                = 0x7b,
	MG_KEY_COPY               = 0x7c,
	MG_KEY_PASTE              = 0x7d,
	MG_KEY_FIND               = 0x7e,
	MG_KEY_MUTE               = 0x7f,
	MG_KEY_VOLUMEUP           = 0x80,
	MG_KEY_VOLUMEDOWN         = 0x81,
	MG_KEY_LOCKINGCAPSLOCK    = 0x82, /* legacy, disabled in SDL */
	MG_KEY_LOCKINGNUMLOCK     = 0x83, /* legacy, disabled in SDL */
	MG_KEY_LOCKINGSCROLLLOCK  = 0x84, /* legacy, disabled in SDL */

	/* !! these two are never generated on X11 & Wayland !! */
	MG_KEY_KP_COMMA           = 0x85,
	MG_KEY_KP_EQUALSAS400     = 0x86,

	/* !! all of these are never generated on X11 & Wayland !! */
	MG_KEY_INTERNATIONAL1     = 0x87,
	MG_KEY_INTERNATIONAL2     = 0x88,
	MG_KEY_INTERNATIONAL3     = 0x89,
	MG_KEY_INTERNATIONAL4     = 0x8a,
	MG_KEY_INTERNATIONAL5     = 0x8b,
	MG_KEY_INTERNATIONAL6     = 0x8c,
	MG_KEY_INTERNATIONAL7     = 0x8d,
	MG_KEY_INTERNATIONAL8     = 0x8e,
	MG_KEY_INTERNATIONAL9     = 0x8f,
	MG_KEY_LANG1              = 0x90, /* hangul/english toggle */
	MG_KEY_LANG2              = 0x91, /* hanja conversion */
	MG_KEY_LANG3              = 0x92, /* katakana */
	MG_KEY_LANG4              = 0x93, /* hiragana */
	MG_KEY_LANG5              = 0x94, /* zenkaku/hankaku */
	MG_KEY_LANG6              = 0x95, /* reserved */
	MG_KEY_LANG7              = 0x96, /* reserved */
	MG_KEY_LANG8              = 0x97, /* reserved */
	MG_KEY_LANG9              = 0x98, /* reserved */

	MG_KEY_ALTERASE           = 0x99, /* erase-eaze */
	MG_KEY_SYSREQ             = 0x9a,
	MG_KEY_CANCEL             = 0x9b,
	MG_KEY_CLEAR              = 0x9c,
	MG_KEY_PRIOR              = 0x9d,
	MG_KEY_RETURN2            = 0x9e,
	MG_KEY_SEPARATOR          = 0x9f,
	MG_KEY_OUT                = 0xa0,
	MG_KEY_OPER               = 0xa1,
	MG_KEY_CLEARAGAIN         = 0xa2,
	MG_KEY_CRSEL              = 0xa3,
	MG_KEY_EXSEL              = 0xa4,

	/* 0xa5 to 0xaf inclusive are reserved */

	/* !! all of these are never generated on X11 & Wayland !! */
	MG_KEY_KP_00              = 0xb0,
	MG_KEY_KP_000             = 0xb1,
	MG_KEY_THOUSANDSSEPARATOR = 0xb2,
	MG_KEY_DECIMALSEPARATOR   = 0xb3,
	MG_KEY_CURRENCYUNIT       = 0xb4,
	MG_KEY_CURRENCYSUBUNIT    = 0xb5,
	MG_KEY_KP_LEFTPAREN       = 0xb6,
	MG_KEY_KP_RIGHTPAREN      = 0xb7,
	MG_KEY_KP_LEFTBRACE       = 0xb8,
	MG_KEY_KP_RIGHTBRACE      = 0xb9,
	MG_KEY_KP_TAB             = 0xba,
	MG_KEY_KP_BACKSPACE       = 0xbb,
	MG_KEY_KP_A               = 0xbc,
	MG_KEY_KP_B               = 0xbd,
	MG_KEY_KP_C               = 0xbe,
	MG_KEY_KP_D               = 0xbf,
	MG_KEY_KP_E               = 0xc0,
	MG_KEY_KP_F               = 0xc1,
	MG_KEY_KP_XOR             = 0xc2,
	MG_KEY_KP_POWER           = 0xc3,
	MG_KEY_KP_PERCENT         = 0xc4,
	MG_KEY_KP_LESS            = 0xc5,
	MG_KEY_KP_GREATER         = 0xc6,
	MG_KEY_KP_AMPERSAND       = 0xc7,
	MG_KEY_KP_DBLAMPERSAND    = 0xc8,
	MG_KEY_KP_VERTICALBAR     = 0xc9,
	MG_KEY_KP_DBLVERTICALBAR  = 0xca,
	MG_KEY_KP_COLON           = 0xcb,
	MG_KEY_KP_HASH            = 0xcc,
	MG_KEY_KP_SPACE           = 0xcd,
	MG_KEY_KP_AT              = 0xce,
	MG_KEY_KP_EXCLAM          = 0xcf,
	MG_KEY_KP_MEMSTORE        = 0xd0,
	MG_KEY_KP_MEMRECALL       = 0xd1,
	MG_KEY_KP_MEMCLEAR        = 0xd2,
	MG_KEY_KP_MEMADD          = 0xd3,
	MG_KEY_KP_MEMSUBTRACT     = 0xd4,
	MG_KEY_KP_MEMMULTIPLY     = 0xd5,
	MG_KEY_KP_MEMDIVIDE       = 0xd6,
	MG_KEY_KP_PLUSMINUS       = 0xd7,
	MG_KEY_KP_CLEAR           = 0xd8,
	MG_KEY_KP_CLEARENTRY      = 0xd9,
	MG_KEY_KP_BINARY          = 0xda,
	MG_KEY_KP_OCTAL           = 0xdb,
	MG_KEY_KP_DECIMAL         = 0xdc,
	MG_KEY_KP_HEXADECIMAL     = 0xdd,

	/* 0xde and 0xdf are reserved */

	MG_KEY_LCTRL              = 0xe0,
	MG_KEY_LSHIFT             = 0xe1,
	MG_KEY_LALT               = 0xe2, /* alt, option */
	MG_KEY_LGUI               = 0xe3, /* super (windows/command) */
	MG_KEY_RCTRL              = 0xe4,
	MG_KEY_RSHIFT             = 0xe5,
	MG_KEY_RALT               = 0xe6, /* altgr, option */
	MG_KEY_RGUI               = 0xe7  /* super (windows/command) */
};

/* a mouse button is represented one of the following values: */
enum mg_mouse_btn {
	MG_MOUSE_UNKNOWN,
	MG_MOUSE_LEFT,
	MG_MOUSE_MIDDLE,
	MG_MOUSE_RIGHT,
	MG_MOUSE_SIDE,
	MG_MOUSE_EXTRA
	/*
	 * note -- mouse buttons past 5 aren't really standardized, so there
	 * isn't a good consistent way to support more
	 */
};

/* available pixel formats are: */
enum mg_pixel_format {
	MG_PIXEL_FORMAT_RGBX, /* RGBA with A component ignored, 32 bpp */
	MG_PIXEL_FORMAT_BGRX, /* BGRA with A component ignored, 32 bpp */
	MG_PIXEL_FORMAT_XRGB, /* ARGB with A component ignored, 32 bpp */
	MG_PIXEL_FORMAT_XBGR, /* ABGR with A component ignored, 32 bpp */
	MG_PIXEL_FORMAT_256   /* mode 13h color palette, "8 bpp" */
};

/*
 * when an event is recieved (see below on how they are recieved), it
 * is stored in a structure with the following layout:
 */
struct mg_event {
	/* bitfield of `enum mg_event_type`s */
	uint32_t events;

	enum mg_key keydown;         /* only if (events & MG_KEYDOWN) */
	enum mg_key keyup;           /* only if (events & MG_KEYUP) */
	enum mg_mouse_btn mousedown; /* only if (events & MG_MOUSEDOWN) */
	enum mg_mouse_btn mouseup;   /* only if (events & MG_MOUSEUP) */
	int mousemotion_x;           /* only if (events & MG_MOUSEMOTION) */
	int mousemotion_y;           /* only if (events & MG_MOUSEMOTION) */
};

/*
 * now, for the functions.
 *
 * before doing anything with the library, you must initialize it by calling:
 */
MG_API void mg_init(int w, int h, const char *title, jmp_buf err_return);
/*
 * the `w` and `h` parameters specify the requested size for the window -- the
 * actual width and height might be different and will be stored in the
 * mg_width and mg_height variables.
 *
 * the `title` parameter specifies the requested title for the window.
 *
 * the `err_return` parameter must be a valid jmp_buf initialized by a call to
 * setjmp(). if an error is ever encountered, a longjmp() to there occurs;
 * you can use the variable `mg_errstatus` to determine what error occurred.
 */

/*
 * the window is configurable using:
 */
MG_API void mg_fullscreen(int enable);
MG_API void mg_set_title(const char *title);
/*
 * if an error occurs, to get an error message, use:
 */
MG_API const char *mg_errstring();
/*
 * this also includes an strerror() of `mg_storederrno` if applicable.
 *
 * once you are ready to quit, call:
 */
MG_API void mg_quit(void);
/*
 * to exit the library; this will close the window.
 * you should also call this if a library error occurs; it's safe to call at
 * any point after mg_init() even if it errored.
 */

/*
 * to recieve events, call one of:
 */
MG_API int mg_getevent(struct mg_event *event);
MG_API void mg_waitevent(struct mg_event *event);
MG_API int mg_waiteventfor(struct mg_event *event, int ms);
/*
 * the event data will be stored inside the struct pointed to by `event`.
 *
 * mg_getevent returns instantly -- if no events are currently pending,
 * 0 is returned; otherwise, 1 is returned.
 * mg_waitevent blocks until an event is recieved.
 * mg_waiteventfor does the same, but returns early if `ms` milliseconds
 * elapsed without an event.
 * mg_waiteventfor(&ev, 0) is equivalent to mg_getevent(&ev).
 */

/*
 * to draw things on the window, use one of the following functions:
 */

/* clear everything on the window with the current background color. */
MG_API void mg_clear(void);

/*
 * draw the contents of the memory buffer `data`. the pixel format is
 * determined by `pixel_format`. each value represents 1 pixel.
 *
 * for 1 byte-per-pixel pixel formats, `data` will internally be cast to a
 * (uint8_t *). thus, if you want to use a 1 byte-per-pixel pixel format,
 * you should use a (uint8_t *) and pass it as the 'data' parameter.
 * note that you may have to cast it to (uint32_t *) in this case.
 *
 * `width` and `height` specify the buffer's width and height in PIXELS.
 *
 * if `width` is larger than buffer's width or `height` is larger than
 * the buffer's height, the behavior is undefined. if `width` is smaller
 * than the buffer's width, it'll just result in a messed up looking image. if
 * `height` is smaller than the buffer's height, it'll work as you'd expect --
 * the resulting image will be cropped.
 *
 * if either `width` or `height` are zero, nothing is drawn.
 *
 * the top-left corner of the drawn buffer will be at (x, y).
 */
MG_API void mg_draw(const uint32_t *data, uint32_t width, uint32_t height,
		enum mg_pixel_format pixel_format, int x, int y);

/*
 * commit all changes to the window -- calling this is necessary to be
 * 100% sure your changes are actually displayed on the window.
 */
MG_API void mg_flush(void);

/*
 * set the current background color to the color specified by the
 * RGB value (r, g, b).
 * the default is (0xff, 0xff, 0xff) (white).
 */
MG_API void mg_setbgcolor(uint8_t r, uint8_t g, uint8_t b);

/* end of docs/header */

#endif /* !defined(MG_H) */

/*
 * ===========================================================================
 * IMPLEMENTATION
 */
#if defined(MG_IMPLEMENTATION)

#if !defined(MG_BACKEND_X11) && !defined(MG_BACKEND_WAYLAND)
#error please define a backend for minigraphics.
#elif defined(MG_BACKEND_X11) && defined(MG_BACKEND_WAYLAND)
#error only one backend may be defined.
#endif /* [!]defined(MG_BACKEND_X11) && [!]defined(MG_BACKEND_WAYLAND) */

/*
 * ===========================================================================
 * CONSTANTS
 */
static const char *mg__strerrors[] = {
	"connection to display failed",
	"out of memory",
	"IO error: ",
	"failed to set up keyboard",
	"X11 backend: unsupported color depth",
	"Wayland backend: unsupported keymap",
	"Wayland backend: protocol/IO error: ",
	"Wayland backend: error creating shared memory object: ",
};

#if defined(MG_BACKEND_X11) || defined(MG_BACKEND_WAYLAND)

struct mg__xkb_name_key_pair {
	const char *xkb_name;
	enum mg_key key;
};

static const struct mg__xkb_name_key_pair mg__xkb_name_key_lookup[] = {
	/* fn row */
	{ "ESC",  MG_KEY_ESCAPE },
	{ "FK01", MG_KEY_F1 },
	{ "FK02", MG_KEY_F2 },
	{ "FK03", MG_KEY_F3 },
	{ "FK04", MG_KEY_F4 },
	{ "FK05", MG_KEY_F5 },
	{ "FK06", MG_KEY_F6 },
	{ "FK07", MG_KEY_F7 },
	{ "FK08", MG_KEY_F8 },
	{ "FK09", MG_KEY_F9 },
	{ "FK10", MG_KEY_F10 },
	{ "FK11", MG_KEY_F11 },
	{ "FK12", MG_KEY_F12 },

	/* extended fn keys */
	{ "FK13", MG_KEY_F13 },
	{ "FK14", MG_KEY_F14 },
	{ "FK15", MG_KEY_F15 },
	{ "FK16", MG_KEY_F16 },
	{ "FK17", MG_KEY_F17 },
	{ "FK18", MG_KEY_F18 },
	{ "FK19", MG_KEY_F19 },
	{ "FK20", MG_KEY_F20 },
	{ "FK21", MG_KEY_F21 },
	{ "FK22", MG_KEY_F22 },
	{ "FK23", MG_KEY_F23 },
	{ "FK24", MG_KEY_F24 },

	/* prtsc, scrlk, pause */
	{ "PRSC", MG_KEY_PRINTSCREEN },
	{ "SCLK", MG_KEY_SCROLLLOCK },
	{ "PAUS", MG_KEY_PAUSE },

	/* top row (with the numbers) */
	{ "TLDE", MG_KEY_GRAVE },
	{ "AE01", MG_KEY_1 },
	{ "AE02", MG_KEY_2 },
	{ "AE03", MG_KEY_3 },
	{ "AE04", MG_KEY_4 },
	{ "AE05", MG_KEY_5 },
	{ "AE06", MG_KEY_6 },
	{ "AE07", MG_KEY_7 },
	{ "AE08", MG_KEY_8 },
	{ "AE09", MG_KEY_9 },
	{ "AE10", MG_KEY_0 },
	{ "AE11", MG_KEY_MINUS },
	{ "AE12", MG_KEY_EQUALS },
	{ "BKSP", MG_KEY_BACKSPACE },

	/* qwerty... row */
	{ "TAB",  MG_KEY_TAB },
	{ "AD01", MG_KEY_Q },
	{ "AD02", MG_KEY_W },
	{ "AD03", MG_KEY_E },
	{ "AD04", MG_KEY_R },
	{ "AD05", MG_KEY_T },
	{ "AD06", MG_KEY_Y },
	{ "AD07", MG_KEY_U },
	{ "AD08", MG_KEY_I },
	{ "AD09", MG_KEY_O },
	{ "AD10", MG_KEY_P },
	{ "AD11", MG_KEY_LEFTBRACKET },
	{ "AD12", MG_KEY_RIGHTBRACKET },
	{ "BKSL", MG_KEY_BACKSLASH }, /* also non-US hash */

	/* asdfgh... row */
	{ "CAPS", MG_KEY_CAPSLOCK },
	{ "AC01", MG_KEY_A },
	{ "AC02", MG_KEY_S },
	{ "AC03", MG_KEY_D },
	{ "AC04", MG_KEY_F },
	{ "AC05", MG_KEY_G },
	{ "AC06", MG_KEY_H },
	{ "AC07", MG_KEY_J },
	{ "AC08", MG_KEY_K },
	{ "AC09", MG_KEY_L },
	{ "AC10", MG_KEY_SEMICOLON },
	{ "AC11", MG_KEY_APOSTROPHE },
	{ "RTRN", MG_KEY_RETURN },

	/* zxcvbn... row */
	{ "LFSH", MG_KEY_LSHIFT },
	{ "LSGT", MG_KEY_NONUSBACKSLASH },
	{ "AB01", MG_KEY_Z },
	{ "AB02", MG_KEY_X },
	{ "AB03", MG_KEY_C },
	{ "AB04", MG_KEY_V },
	{ "AB05", MG_KEY_B },
	{ "AB06", MG_KEY_N },
	{ "AB07", MG_KEY_M },
	{ "AB08", MG_KEY_COMMA },
	{ "AB09", MG_KEY_PERIOD },
	{ "AB10", MG_KEY_SLASH },
	{ "RTSH", MG_KEY_RSHIFT },

	/* modifiers & space */
	{ "LCTL", MG_KEY_LCTRL },
	{ "LWIN", MG_KEY_LGUI },
	{ "LALT", MG_KEY_LALT },
	{ "SPCE", MG_KEY_SPACE },
	{ "RALT", MG_KEY_RALT },
	{ "RWIN", MG_KEY_RGUI },
	{ "MENU", MG_KEY_APPLICATION },
	{ "RCTL", MG_KEY_RCTRL },

	/* nav cluster */
	{ "INS",  MG_KEY_INSERT },
	{ "HOME", MG_KEY_HOME },
	{ "PGUP", MG_KEY_PAGEUP },
	{ "DELE", MG_KEY_DELETE },
	{ "END",  MG_KEY_END },
	{ "PGDN", MG_KEY_PAGEDOWN },

	/* arrow keys */
	{ "LEFT", MG_KEY_LEFT },
	{ "DOWN", MG_KEY_DOWN },
	{ "UP",   MG_KEY_UP },
	{ "RGHT", MG_KEY_RIGHT },

	/* numpad */
	{ "NMLK", MG_KEY_NUMLOCKCLEAR },
	{ "KPDV", MG_KEY_KP_DIVIDE },
	{ "KPMU", MG_KEY_KP_MULTIPLY },
	{ "KPSU", MG_KEY_KP_MINUS },
	{ "KPAD", MG_KEY_KP_PLUS },
	{ "KPEN", MG_KEY_KP_ENTER },

	{ "KP1",  MG_KEY_KP_1 },
	{ "KP2",  MG_KEY_KP_2 },
	{ "KP3",  MG_KEY_KP_3 },
	{ "KP4",  MG_KEY_KP_4 },
	{ "KP5",  MG_KEY_KP_5 },
	{ "KP6",  MG_KEY_KP_6 },
	{ "KP7",  MG_KEY_KP_7 },
	{ "KP8",  MG_KEY_KP_8 },
	{ "KP9",  MG_KEY_KP_9 },
	{ "KP0",  MG_KEY_KP_0 },
	{ "KPDL", MG_KEY_KP_PERIOD },
	{ "KPEQ", MG_KEY_KP_EQUALS },

	/* power (that is, if it doesn't use the consumer page 0x0c) */
	{ "POWR", MG_KEY_POWER }
};

#endif /* defined(MG_BACKEND_X11) && defined(MG_BACKEND_WAYLAND) */

/*
 * ===========================================================================
 * X11 BACKEND
 */
#if defined(MG_BACKEND_X11)

#if _POSIX_C_SOURCE < 200112L
#undef _POSIX_C_SOURCE
#define _POSIX_C_SOURCE 200112L
#endif /* _POSIX_C_SOURCE < 200112L */

#include <errno.h>
#include <limits.h>
#include <poll.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#include <X11/Xlib.h>
#include <X11/XKBlib.h>
#include <X11/Xatom.h>
#include <X11/Xutil.h>

/*
 * -----------------------------------
 * constants
 */
static const uint32_t mg__256_palette[256] = {
	0x00000000, 0xaa020000, 0x00aa1400, 0xaaaa0000, 0x0300aa00, 0xaa00aa00, 0x0055aa00, 0xaaaaaa00,
	0x55555500, 0xff555500, 0x55ff5500, 0xffff5500, 0x5555ff00, 0xff55fd00, 0x55ffff00, 0xffffff00,
	0x00000000, 0x10101000, 0x20202000, 0x35353500, 0x45454500, 0x55555500, 0x65656500, 0x75757500,
	0x8a8a8a00, 0x9a9a9a00, 0xaaaaaa00, 0xbababa00, 0xcacaca00, 0xdfdfdf00, 0xefefef00, 0xffffff00,
	0xff040000, 0xff044100, 0xff038200, 0xff02be00, 0xff00fd00, 0xbe00fe00, 0x8200ff00, 0x4100ff00,
	0x0800ff00, 0x0541ff00, 0x0082ff00, 0x00beff00, 0x00ffff00, 0x00ffbe00, 0x00ff8200, 0x01ff4100,
	0x00ff2400, 0x42ff2200, 0x82ff1d00, 0xbeff1200, 0xffff0000, 0xffbe0000, 0xff820100, 0xff410000,
	0xff828200, 0xff829e00, 0xff82be00, 0xff82df00, 0xff82fd00, 0xdf82fe00, 0xbe82ff00, 0x9e82ff00,
	0x8282ff00, 0x829eff00, 0x82beff00, 0x82dfff00, 0x82ffff00, 0x82ffdf00, 0x82ffbe00, 0x82ff9e00,
	0x82ff8200, 0x9eff8200, 0xbeff8200, 0xdfff8200, 0xffff8200, 0xffdf8200, 0xffbe8200, 0xff9e8200,
	0xffbaba00, 0xffbaca00, 0xffbadf00, 0xffbaef00, 0xffbafe00, 0xefbafe00, 0xdfbaff00, 0xcabaff00,
	0xbabaff00, 0xbacaff00, 0xbadfff00, 0xbaefff00, 0xbaffff00, 0xbaffef00, 0xbaffdf00, 0xbbffca00,
	0xbaffba00, 0xcaffba00, 0xdfffba00, 0xefffba00, 0xffffba00, 0xffefba00, 0xffdfba00, 0xffcaba00,
	0x71010100, 0x71011c00, 0x71013900, 0x71005500, 0x71007100, 0x55007100, 0x39007100, 0x1c007100,
	0x01007100, 0x011c7100, 0x00397100, 0x00557100, 0x00717100, 0x00715500, 0x00713900, 0x00711c00,
	0x00710900, 0x1c710900, 0x39710600, 0x55710300, 0x71710000, 0x71550000, 0x71390000, 0x711c0000,
	0x71393900, 0x71394500, 0x71395500, 0x71396100, 0x71397100, 0x61397100, 0x55397100, 0x45397100,
	0x39397100, 0x39457100, 0x39557100, 0x39617100, 0x39717100, 0x39716100, 0x39715500, 0x3a714500,
	0x39713900, 0x45713900, 0x55713900, 0x61713900, 0x71713900, 0x71613900, 0x71553900, 0x72453900,
	0x71515100, 0x71515900, 0x71516100, 0x71516900, 0x71517100, 0x69517100, 0x61517100, 0x59517100,
	0x51517100, 0x51597100, 0x51617100, 0x51697100, 0x51717100, 0x51716900, 0x51716100, 0x51715900,
	0x51715100, 0x5a715100, 0x61715100, 0x69715100, 0x71715100, 0x71695100, 0x71615100, 0x71595100,
	0x42000000, 0x41001100, 0x41002000, 0x41003100, 0x41004100, 0x32004100, 0x20004100, 0x10004100,
	0x00004100, 0x00104100, 0x00204100, 0x00314100, 0x00414100, 0x00413100, 0x00412000, 0x00411000,
	0x00410300, 0x10410300, 0x20410200, 0x31410100, 0x41410000, 0x41310000, 0x41200000, 0x41100000,
	0x41202000, 0x41202800, 0x41203100, 0x41203900, 0x41204100, 0x39204100, 0x31204100, 0x28204100,
	0x20204100, 0x20284100, 0x20314100, 0x21394100, 0x20414100, 0x20413900, 0x20413100, 0x20412800,
	0x20412000, 0x28412000, 0x31412000, 0x39412000, 0x41412000, 0x41392000, 0x41312000, 0x41282000,
	0x412d2d00, 0x412d3100, 0x412d3500, 0x412d3d00, 0x412d4100, 0x3d2d4100, 0x352d4100, 0x312d4100,
	0x2d2d4100, 0x2d314100, 0x2d354100, 0x2d3d4100, 0x2d414100, 0x2d413d00, 0x2d413500, 0x2d413100,
	0x2d412d00, 0x31412d00, 0x35412d00, 0x3d412d00, 0x41412d00, 0x413d2d00, 0x41352d00, 0x41312d00,
	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000
};

/*
 * -----------------------------------
 * macros
 */
#define MG__ERROR(errstatus) { mg_errstatus = errstatus; mg_storederrno = errno; longjmp(mg.err_return, 1); }
#define MG__ERRSTRING_BUFSIZE 256
#define MG__MIN(x, y) ((x < y) ? x : y)
#define MG__X_EVENT_MASK ExposureMask | StructureNotifyMask | KeyPressMask | \
	KeyReleaseMask | ButtonPressMask | ButtonReleaseMask

#define MG__NSEC 1000000000

/*
 * -----------------------------------
 * global library state
 */
struct mg__state {
	/* X stuff */
	int screen;
	Display *dpy;
	Window root, win;
	GC gc;
	Colormap colormap;
	unsigned int depth;

	/* keycode -> mg_key lookup table */
	enum mg_key keycode_lookup[256];

	/* "constants" */
	Atom wmdeletewin;
	Atom wmstate;
	Atom fullscreen;
	unsigned long white;
	unsigned long bgcolor;

	/* pixmap */
	Pixmap pixmap;
	uint32_t pixmap_w, pixmap_h;

	/* misc. library state */
	jmp_buf err_return;
};

static struct mg__state mg;

/*
 * -----------------------------------
 * public API global variables
 */
int mg_width;
int mg_height;
enum mg_error mg_errstatus;
int mg_storederrno;

/*
 * -----------------------------------
 * internal functions
 */
static int
mg__handle_x_event(struct mg_event *event, XEvent *xevnt)
{
	static int pressed = 0;
	static unsigned int lastkeycode;
	switch (xevnt->type) {
	case ClientMessage:
		/* we got a message */
		if ((Atom)xevnt->xclient.data.l[0] == mg.wmdeletewin) {
			event->events |= MG_QUIT;
			return 1;
		}
		break;
	case ConfigureNotify:
		/* the window has changed somehow */
		if (xevnt->xconfigure.width != mg_width || xevnt->xconfigure.height != mg_height) {
			mg_width = xevnt->xconfigure.width;
			mg_height = xevnt->xconfigure.height;
			event->events |= MG_RESIZE;
			return 1;
		}
		break;
	case Expose:
		event->events |= MG_REDRAW;
		return 1;
	case KeyPress:
		if (pressed && xevnt->xkey.keycode == lastkeycode) {
			lastkeycode = xevnt->xkey.keycode;
			break;
		}
		pressed = 1;
		lastkeycode = xevnt->xkey.keycode;
		/* XEvent.xkey.keycode is guaranteed to fit into a uint8 */
		event->keydown = mg.keycode_lookup[xevnt->xkey.keycode];
		event->events |= MG_KEYDOWN;
		return 1;
	case KeyRelease:
		if (pressed && xevnt->xkey.keycode == lastkeycode)
			pressed = 0;
		event->keyup = mg.keycode_lookup[xevnt->xkey.keycode];
		event->events |= MG_KEYUP;
		return 1;
	case ButtonPress:
		if (xevnt->xbutton.x >= 0 && xevnt->xbutton.y >= 0) {
			enum mg_mouse_btn button = MG_MOUSE_UNKNOWN;
			switch (xevnt->xbutton.button) {
			case 1: button = MG_MOUSE_LEFT; break;
			case 2: button = MG_MOUSE_MIDDLE; break;
			case 3: button = MG_MOUSE_RIGHT; break;
			case 8: button = MG_MOUSE_SIDE; break;
			case 9:	button = MG_MOUSE_EXTRA; break;
			}
			event->mousedown = button;
			event->events |= MG_MOUSEDOWN;
			return 1;
		}
		break;
	case ButtonRelease:
		if (xevnt->xbutton.x >= 0 && xevnt->xbutton.y >= 0) {
			enum mg_mouse_btn button;
			int set = 0;
			switch (xevnt->xbutton.button) {
			case 1:
				button = MG_MOUSE_LEFT;
				set = 1;
				break;
			case 2:
				button = MG_MOUSE_MIDDLE;
				set = 1;
				break;
			case 3:
				button = MG_MOUSE_RIGHT;
				set = 1;
				break;
			case 8:
				button = MG_MOUSE_SIDE;
				set = 1;
				break;
			case 9:
				button = MG_MOUSE_EXTRA;
				set = 1;
				break;
			}
			if (set) {
				event->mouseup = button;
				event->events |= MG_MOUSEUP;
				return 1;
			}
		}
		break;
	case MotionNotify:
		if (xevnt->xmotion.x >= 0 && xevnt->xmotion.y >= 0) {
			Window dummy1, dummy2;
			int dummy3, dummy4;
			unsigned int dummy5;

			int x, y;

			if (XQueryPointer(mg.dpy, mg.win, &dummy1, &dummy2, &dummy3, &dummy4, &x, &y, &dummy5)) {
				if (x >= 0 && y >= 0) {
					event->mousemotion_x = x;
					event->mousemotion_y = y;
					event->events |= MG_MOUSEMOTION;
					return 1;
				}
			}
		}
		break;
	}
	return 0;
}

static uint32_t
mg__ms_until(const struct timespec *time)
{
        struct timespec now;
        clock_gettime(CLOCK_MONOTONIC, &now);

        if (now.tv_sec > time->tv_sec || (now.tv_sec == time->tv_sec && now.tv_nsec > time->tv_nsec))
                return 0;

        uint32_t sec = (uint32_t)(time->tv_sec - now.tv_sec);
        uint32_t nsec;
        if (now.tv_nsec > time->tv_nsec) {
                sec--;
                nsec = MG__NSEC - (uint32_t)(now.tv_nsec - time->tv_nsec);
        } else {
                nsec = (uint32_t)(time->tv_nsec - now.tv_nsec);
        }

        return sec * 1000 + nsec / 1000000;
}

/*
 * -----------------------------------
 * public API functions: initialization, shutdown, errors
 */
void
mg_init(int w, int h, const char *title, jmp_buf err_return)
{
	XkbDescPtr kbd;
	int xkbmajver = XkbMajorVersion;
	int xkbminver = XkbMinorVersion;
	int opcode, event, error;
	size_t i;
	int code;

	XEvent xevnt;

	*mg.err_return = *err_return;

	/* assign some sentinel values before the first possibility of an error */
	mg.dpy = NULL;
	mg.win = None;
	mg.gc = NULL;
	mg.pixmap_w = mg.pixmap_h = 0;

	/* open display */
	mg.dpy = XOpenDisplay(NULL);
	if (!mg.dpy)
		MG__ERROR(MG_CONNECTION_FAILED)

	/* set detectable autorepeat */
	XkbSetDetectableAutoRepeat(mg.dpy, True, NULL);

	/* fill keycode lookup table */
	if (!XkbQueryExtension(mg.dpy, &opcode, &event, &error, &xkbmajver, &xkbminver))
		MG__ERROR(MG_KEYBOARD_SETUP_FAILED)
	kbd = XkbGetMap(mg.dpy, XkbKeyTypesMask | XkbKeySymsMask, XkbUseCoreKbd);
	if (!kbd)
		MG__ERROR(MG_KEYBOARD_SETUP_FAILED)
	if (XkbGetNames(mg.dpy, XkbKeyNamesMask, kbd) != Success) {
		XkbFreeKeyboard(kbd, 0, True);
		MG__ERROR(MG_KEYBOARD_SETUP_FAILED)
	}
	for (i = 0; i < sizeof(mg.keycode_lookup) / sizeof(mg.keycode_lookup[0]); i++)
		mg.keycode_lookup[i] = MG_KEY_UNKNOWN;
	for (code = kbd->min_key_code; code <= kbd->max_key_code && code <= 0xff; code++) {
		if (kbd->names->keys[code].name[0] == '\0')
			continue;
		for (i = 0; i < sizeof(mg__xkb_name_key_lookup) / sizeof(mg__xkb_name_key_lookup[0]); i++)
			if (strncmp(mg__xkb_name_key_lookup[i].xkb_name, kbd->names->keys[code].name, 4) == 0)
				mg.keycode_lookup[code] = mg__xkb_name_key_lookup[i].key;
	}
	XkbFreeKeyboard(kbd, 0, True);

	/* set screen, root window, colormap, and background color */
	mg.screen = DefaultScreen(mg.dpy);
	mg.root = DefaultRootWindow(mg.dpy);
	mg.colormap = DefaultColormap(mg.dpy, mg.screen);
	mg.depth = (unsigned int)DefaultDepth(mg.dpy, mg.screen);
	mg.bgcolor = mg.white = WhitePixel(mg.dpy, mg.screen);

	/* create window */
	mg.win = XCreateSimpleWindow(mg.dpy, mg.root, 0, 0,
			(unsigned int)w, (unsigned int)h, 0, mg.bgcolor, mg.bgcolor);
	mg_width = w;
	mg_height = h;

	/* name our window */
	XStoreName(mg.dpy, mg.win, title);

	/* specify WM_DELETE_WINDOW protocol */
	mg.wmdeletewin = XInternAtom(mg.dpy, "WM_DELETE_WINDOW", 1);
	XSetWMProtocols(mg.dpy, mg.win, &mg.wmdeletewin, 1);

	/* sentinel values for the other 2 Atoms */
	mg.wmstate = 0;
	mg.fullscreen = 0;

	/* tell X what events we are interested in */
	XSelectInput(mg.dpy, mg.win, MG__X_EVENT_MASK | PointerMotionMask);

	/* map window */
	XMapWindow(mg.dpy, mg.win);

	/* create graphics context */
	mg.gc = XCreateGC(mg.dpy, mg.win, 0, NULL);

	/* set GC colors */
	XSetBackground(mg.dpy, mg.gc, mg.bgcolor);
	XSetWindowBackground(mg.dpy, mg.win, mg.bgcolor);
	XSetForeground(mg.dpy, mg.gc, mg.bgcolor);

	/* wait for window mapping */
	for (;;) {
		XNextEvent(mg.dpy, &xevnt);
		if (xevnt.type == ConfigureNotify) {
			mg_width = xevnt.xconfigure.width;
			mg_height = xevnt.xconfigure.height;
		} else if (xevnt.type == MapNotify) {
			break;
		}
	}
}

void
mg_fullscreen(int enable)
{
	XEvent xev;

	if (mg.wmstate == 0)
		mg.wmstate = XInternAtom(mg.dpy, "_NET_WM_STATE", False);
	if (mg.fullscreen == 0)
		mg.fullscreen = XInternAtom(mg.dpy, "_NET_WM_STATE_FULLSCREEN", False);
	memset(&xev, 0, sizeof(xev));
	xev.type = ClientMessage;
	xev.xclient.window = mg.win;
	xev.xclient.message_type = mg.wmstate;
	xev.xclient.format = 32;

	/*
	 * https://specifications.freedesktop.org/wm-spec/latest/ar01s05.html#id-1.6.8
	 *
	 * _NET_WM_STATE_REMOVE        0       remove/unset property
	 * _NET_WM_STATE_ADD           1       add/set property
	 * _NET_WM_STATE_TOGGLE        2       toggle property
	 */
	xev.xclient.data.l[0] = !!enable;

	xev.xclient.data.l[1] = (long)mg.fullscreen;
	xev.xclient.data.l[2] = 0;
	XSendEvent(mg.dpy, mg.root, False,
			SubstructureRedirectMask | SubstructureNotifyMask, &xev);
}

void
mg_set_title(const char *title)
{
	XStoreName(mg.dpy, mg.win, title);
}

const char *
mg_errstring(void)
{
	static char buf[MG__ERRSTRING_BUFSIZE];
	size_t l = MG__MIN(strlen(mg__strerrors[mg_errstatus]), MG__ERRSTRING_BUFSIZE - 1);

	memcpy(buf, mg__strerrors[mg_errstatus], l);
	buf[l] = '\0';
	if (mg_errstatus == MG_IO_ERROR) {
		const char *e = strerror(mg_storederrno);
		size_t l2 = MG__MIN(strlen(e), MG__ERRSTRING_BUFSIZE - l - 1);
		memcpy(buf + l, e, l2);
		buf[l + l2] = '\0';
	}
	return buf;
}

void
mg_quit(void)
{
	if (mg.dpy) {
		if (mg.pixmap_w != 0 && mg.pixmap_h != 0)
			/* free the pixmap if it exists */
			XFreePixmap(mg.dpy, mg.pixmap);
		if (mg.gc)
			XFreeGC(mg.dpy, mg.gc);
		if (mg.win)
			XDestroyWindow(mg.dpy, mg.win);
		XCloseDisplay(mg.dpy);
	}
}

/*
 * -----------------------------------
 * public API functions: events
 */
int
mg_getevent(struct mg_event *event)
{
	/* this is kinda boiletplate-y but i cant figure out a better solution... */
	XEvent xevnt;

	if (XCheckTypedEvent(mg.dpy, ClientMessage, &xevnt))
		/* check for ClientMessage events first */
		if (mg__handle_x_event(event, &xevnt))
			return 1;
	if (XCheckWindowEvent(mg.dpy, mg.win, MG__X_EVENT_MASK, &xevnt))
		/*
		 * MotionNotify events in xlib are kinda weird and completely clog up
		 * the event queue, so check if we have any non-pointer-motion events
		 */
		if (mg__handle_x_event(event, &xevnt))
			return 1;
	if (XCheckWindowEvent(mg.dpy, mg.win, MG__X_EVENT_MASK | PointerMotionMask, &xevnt))
		/* if not, throw in pointer events too */
		if (mg__handle_x_event(event, &xevnt))
			return 1;
	return 0;
}

void
mg_waitevent(struct mg_event *event)
{
	XEvent xevnt;
	for (;;) {
		/* wait for an X event to happen */
		XNextEvent(mg.dpy, &xevnt);

		/* handle event */
		if (mg__handle_x_event(event, &xevnt))
			break;
	}
}

int
mg_waiteventfor(struct mg_event *event, int ms)
{
	struct timespec timeout;
	struct pollfd pfd;

	XEvent xevnt;
	uint32_t rem;
	int ret;

	if (ms == 0)
		return mg_getevent(event);

	clock_gettime(CLOCK_MONOTONIC, &timeout);
	timeout.tv_sec  += ms / 1000;
	timeout.tv_nsec += (ms % 1000) * 1000000;
	if (timeout.tv_nsec >= MG__NSEC) {
		timeout.tv_nsec -= MG__NSEC;
		timeout.tv_sec++;
	}

	pfd.fd = ConnectionNumber(mg.dpy);
	pfd.events = POLLIN;

	for (;;) {
		/* drain current queue without blocking */
		while (XPending(mg.dpy)) {
			XNextEvent(mg.dpy, &xevnt);

			/* handle event */
			if (mg__handle_x_event(event, &xevnt))
				return 1;
		}

		/* flush buffered data */
		XFlush(mg.dpy);

		/* poll for events with remaining time */
		do {
			/* calculate remaining time */
			rem = mg__ms_until(&timeout);
			if (rem == 0)
				/* out of time */
				return 0;
			/* clamp just in case */
			ret = poll(&pfd, 1, rem <= INT_MAX ? rem : INT_MAX);
		} while (ret < 0 && errno == EINTR);

		if (!(ret > 0 && (pfd.revents & POLLIN))) {
			/* either nothing to read or error */
			if (ret > 0 && (pfd.revents & (POLLERR | POLLHUP | POLLNVAL)))
				MG__ERROR(MG_IO_ERROR);
			return 0; /* timed out */
		}

		/*
		 * we have stuff to read, the next iteration of the loop
		 * will do that
		 */
	}
	return 0; /* should be unreachable */
}

/*
 * -----------------------------------
 * public API functions: drawing
 */
void
mg_clear(void)
{
	XClearWindow(mg.dpy, mg.win);
}

void
mg_draw(const uint32_t *data, uint32_t width, uint32_t height,
		enum mg_pixel_format pixel_format, int x, int y)
{
	XImage *ximage;
	size_t i = 0, j = 0;

	if (width == 0 || height == 0)
		return;

	if (mg.depth < 24)
		MG__ERROR(MG_X11_UNSUPPORTED_COLOR_DEPTH)

	if (mg.pixmap_w != width || mg.pixmap_h != height) {
		/* we need a new pixmap */
		if (mg.pixmap_w != 0 && mg.pixmap_h != 0)
			/* free the old one if it exists */
			XFreePixmap(mg.dpy, mg.pixmap);

		mg.pixmap = XCreatePixmap(mg.dpy, mg.win, width, height, mg.depth);
		mg.pixmap_w = width;
		mg.pixmap_h = height;
	}

	ximage = XCreateImage(mg.dpy, CopyFromParent, mg.depth, ZPixmap,
			0, NULL, width, height, 32, (int)(width * 4));

	ximage->data = malloc(width * height * 4);
	if (!ximage->data)
		MG__ERROR(MG_OUT_OF_MEMORY)

	for (; i < width * height; i++) {
		/* X seems to use BGRX, so convert our buffer to that */
		switch (pixel_format) {
		case MG_PIXEL_FORMAT_RGBX:
			ximage->data[j] =     (char)((data[i] & 0x0000ff00) >> 8);
			ximage->data[j + 1] = (char)((data[i] & 0x00ff0000) >> 16);
			ximage->data[j + 2] = (char)((data[i] & 0xff000000) >> 24);
			break;
		case MG_PIXEL_FORMAT_BGRX:
			ximage->data[j] =     (char)((data[i] & 0xff000000) >> 24);
			ximage->data[j + 1] = (char)((data[i] & 0x00ff0000) >> 16);
			ximage->data[j + 2] = (char)((data[i] & 0x0000ff00) >> 8);
			break;
		case MG_PIXEL_FORMAT_XRGB:
			ximage->data[j] =     (char)( data[i] & 0x000000ff);
			ximage->data[j + 1] = (char)((data[i] & 0x0000ff00) >> 8);
			ximage->data[j + 2] = (char)((data[i] & 0x00ff0000) >> 16);
			break;
		case MG_PIXEL_FORMAT_XBGR:
			ximage->data[j] =     (char)((data[i] & 0x00ff0000) >> 16);
			ximage->data[j + 1] = (char)((data[i] & 0x0000ff00) >> 8);
			ximage->data[j + 2] = (char)( data[i] & 0x000000ff);
			break;
		case MG_PIXEL_FORMAT_256:
			{
				uint32_t px = mg__256_palette[((uint8_t *)data)[i]];
				ximage->data[j] =     (char)((px & 0xff000000) >> 24);
				ximage->data[j + 1] = (char)((px & 0x00ff0000) >> 16);
				ximage->data[j + 2] = (char)((px & 0x0000ff00) >> 8);
			}
			break;
		}
		j += 4;
	}

	XInitImage(ximage);
	XFillRectangle(mg.dpy, mg.pixmap, mg.gc, 0, 0, width, height);
	XPutImage(mg.dpy, mg.pixmap, mg.gc, ximage, 0, 0, 0, 0, width, height);
	XCopyArea(mg.dpy, mg.pixmap, mg.win, mg.gc, 0, 0, width, height, x, y);
	XDestroyImage(ximage);
}

void
mg_flush(void)
{
	XFlush(mg.dpy);
}

void
mg_setbgcolor(uint8_t r, uint8_t g, uint8_t b)
{
	static int unfreed = 0;

	if (unfreed) {
		XFreeColors(mg.dpy, mg.colormap, &mg.bgcolor, 1, 0);
		unfreed = 0;
	}

	if (r == 0 && g == 0 && b == 0) {
		mg.bgcolor = BlackPixel(mg.dpy, mg.screen);
	} else if (r == 0xff && g == 0xff && b == 0xff) {
		mg.bgcolor = mg.white;
	} else {
		XColor color;
		color.red = r * 257;
		color.green = g * 257;
		color.blue = b * 257;

		unfreed = 1;
		XAllocColor(mg.dpy, mg.colormap, &color);
		mg.bgcolor = color.pixel;
	}
	XSetBackground(mg.dpy, mg.gc, mg.bgcolor);
	XSetWindowBackground(mg.dpy, mg.win, mg.bgcolor);
	XSetForeground(mg.dpy, mg.gc, mg.bgcolor);
}
#endif /* defined(MG_BACKEND_X11) */

/*
 * ===========================================================================
 * WAYLAND BACKEND
 */
#if defined(MG_BACKEND_WAYLAND)

#if _POSIX_C_SOURCE < 200112L
#undef _POSIX_C_SOURCE
#define _POSIX_C_SOURCE 200112L
#endif /* _POSIX_C_SOURCE < 200112L */

#if defined(__linux__)
#include <linux/input-event-codes.h>
#else
#define BTN_MOUSE  0x110
#define BTN_LEFT   0x110
#define BTN_RIGHT  0x111
#define BTN_MIDDLE 0x112
#define BTN_SIDE   0x113
#define BTN_EXTRA  0x114
#endif /* defined(__linux__) */

#include <sys/mman.h>

#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <poll.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

#include <wayland-client.h>
#include <xkbcommon/xkbcommon.h>

#include "xdg-shell-client-protocol.h"

/*
 * -----------------------------------
 * constants
 */
static const uint32_t mg__256_palette[256] = {
	0x000000, 0x0002aa, 0x14aa00, 0x00aaaa, 0xaa0003, 0xaa00aa, 0xaa5500, 0xaaaaaa,
	0x555555, 0x5555ff, 0x55ff55, 0x55ffff, 0xff5555, 0xfd55ff, 0xffff55, 0xffffff,
	0x000000, 0x101010, 0x202020, 0x353535, 0x454545, 0x555555, 0x656565, 0x757575,
	0x8a8a8a, 0x9a9a9a, 0xaaaaaa, 0xbababa, 0xcacaca, 0xdfdfdf, 0xefefef, 0xffffff,
	0x0004ff, 0x4104ff, 0x8203ff, 0xbe02ff, 0xfd00ff, 0xfe00be, 0xff0082, 0xff0041,
	0xff0008, 0xff4105, 0xff8200, 0xffbe00, 0xffff00, 0xbeff00, 0x82ff00, 0x41ff01,
	0x24ff00, 0x22ff42, 0x1dff82, 0x12ffbe, 0x00ffff, 0x00beff, 0x0182ff, 0x0041ff,
	0x8282ff, 0x9e82ff, 0xbe82ff, 0xdf82ff, 0xfd82ff, 0xfe82df, 0xff82be, 0xff829e,
	0xff8282, 0xff9e82, 0xffbe82, 0xffdf82, 0xffff82, 0xdfff82, 0xbeff82, 0x9eff82,
	0x82ff82, 0x82ff9e, 0x82ffbe, 0x82ffdf, 0x82ffff, 0x82dfff, 0x82beff, 0x829eff,
	0xbabaff, 0xcabaff, 0xdfbaff, 0xefbaff, 0xfebaff, 0xfebaef, 0xffbadf, 0xffbaca,
	0xffbaba, 0xffcaba, 0xffdfba, 0xffefba, 0xffffba, 0xefffba, 0xdfffba, 0xcaffbb,
	0xbaffba, 0xbaffca, 0xbaffdf, 0xbaffef, 0xbaffff, 0xbaefff, 0xbadfff, 0xbacaff,
	0x010171, 0x1c0171, 0x390171, 0x550071, 0x710071, 0x710055, 0x710039, 0x71001c,
	0x710001, 0x711c01, 0x713900, 0x715500, 0x717100, 0x557100, 0x397100, 0x1c7100,
	0x097100, 0x09711c, 0x067139, 0x037155, 0x007171, 0x005571, 0x003971, 0x001c71,
	0x393971, 0x453971, 0x553971, 0x613971, 0x713971, 0x713961, 0x713955, 0x713945,
	0x713939, 0x714539, 0x715539, 0x716139, 0x717139, 0x617139, 0x557139, 0x45713a,
	0x397139, 0x397145, 0x397155, 0x397161, 0x397171, 0x396171, 0x395571, 0x394572,
	0x515171, 0x595171, 0x615171, 0x695171, 0x715171, 0x715169, 0x715161, 0x715159,
	0x715151, 0x715951, 0x716151, 0x716951, 0x717151, 0x697151, 0x617151, 0x597151,
	0x517151, 0x51715a, 0x517161, 0x517169, 0x517171, 0x516971, 0x516171, 0x515971,
	0x000042, 0x110041, 0x200041, 0x310041, 0x410041, 0x410032, 0x410020, 0x410010,
	0x410000, 0x411000, 0x412000, 0x413100, 0x414100, 0x314100, 0x204100, 0x104100,
	0x034100, 0x034110, 0x024120, 0x014131, 0x004141, 0x003141, 0x002041, 0x001041,
	0x202041, 0x282041, 0x312041, 0x392041, 0x412041, 0x412039, 0x412031, 0x412028,
	0x412020, 0x412820, 0x413120, 0x413921, 0x414120, 0x394120, 0x314120, 0x284120,
	0x204120, 0x204128, 0x204131, 0x204139, 0x204141, 0x203941, 0x203141, 0x202841,
	0x2d2d41, 0x312d41, 0x352d41, 0x3d2d41, 0x412d41, 0x412d3d, 0x412d35, 0x412d31,
	0x412d2d, 0x41312d, 0x41352d, 0x413d2d, 0x41412d, 0x3d412d, 0x35412d, 0x31412d,
	0x2d412d, 0x2d4131, 0x2d4135, 0x2d413d, 0x2d4141, 0x2d3d41, 0x2d3541, 0x2d3141,
	0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000
};

/*
 * -----------------------------------
 * macros
 */
#define MG__ERROR(errstatus) { mg_errstatus = errstatus; mg_storederrno = errno; longjmp(mg.err_return, 1); }
#define MG__ERROR_NO_ERRNO(errstatus) { mg_errstatus = errstatus; longjmp(mg.err_return, 1); }
#define MG__ERRSTRING_BUFSIZE 256
#define MG__MIN(x, y) (((x) < (y)) ? (x) : (y))

#define MG__NSEC 1000000000

/*
 * -----------------------------------
 * types
 */

/* keyboard event data */
struct mg__keyboard_event {
	uint32_t serial;
	uint32_t time;
	uint32_t key;
	uint32_t state;
};

/* pointer event data */
enum mg__pointer_event_type {
	MG__PTR_ENTER,
	MG__PTR_LEAVE,
	MG__PTR_MOTION,
	MG__PTR_BUTTON,
	MG__PTR_AXIS
};

struct mg__pointer_enter_leave_event {
	uint32_t serial;
	struct wl_surface *surface;
	wl_fixed_t surface_x; /* enter only */
	wl_fixed_t surface_y; /* enter only */
};

struct mg__pointer_motion_event {
	uint32_t time;
	wl_fixed_t surface_x;
	wl_fixed_t surface_y;
};

struct mg__pointer_button_event {
	uint32_t serial;
	uint32_t time;
	uint32_t button;
	uint32_t state;
};

struct mg__pointer_axis_event {
	uint32_t time;
	uint32_t axis;
	wl_fixed_t value;
};

union mg__pointer_event_data {
	struct mg__pointer_enter_leave_event enter;
	struct mg__pointer_enter_leave_event leave;
	struct mg__pointer_motion_event motion;
	struct mg__pointer_button_event button;
	struct mg__pointer_axis_event axis;
};

struct mg__pointer_event {
	enum mg__pointer_event_type type;
	union mg__pointer_event_data data;
};

/* event holder */
struct mg__event_holder {
	int waiting;
	int (*gate)(void *, const void *);
	void *gatedata;
	void *ev;
};

/*
 * -----------------------------------
 * global library state
 */
struct mg__state {
	/* globals */
	struct wl_display *wl_display;
	struct wl_registry *wl_registry;
	struct wl_shm *wl_shm;
	struct wl_compositor *wl_compositor;
	struct xdg_wm_base *xdg_wm_base;
	struct wl_seat *wl_seat;

	/* objects */
	struct wl_surface *wl_surface;
	struct xdg_toplevel *xdg_toplevel;
	struct xdg_surface *xdg_surface;
	struct wl_keyboard *wl_keyboard;
	struct wl_pointer *wl_pointer;

	/* state */
	int configured;
	struct xkb_context *xkb_context;
	struct xkb_keymap *xkb_keymap;
	struct xkb_state *xkb_state;

	/* event holders */
	struct mg__event_holder *close_holder;
	struct mg__event_holder *resize_holder;
	struct mg__event_holder *kbd_holder;
	struct mg__event_holder *pointer_holder;

	/* keycode -> mg_key lookup table */
	enum mg_key keycode_lookup[256];

	/* misc. library state */
	uint32_t *draw_buf;
	uint32_t bgcolor;
	size_t buf_width, buf_height, buf_stride, buf_size;
	jmp_buf err_return;
};

static struct mg__state mg;

/*
 * -----------------------------------
 * public API global variables
 */
int mg_width;
int mg_height;
enum mg_error mg_errstatus;
int mg_storederrno;

/*
 * -----------------------------------
 * internal functions: draw buffer utility
 */
static void
mg__clear_buf(uint32_t *buf, size_t w, size_t h)
{
	size_t i = 0;
	for (; i < w * h; i++)
		buf[i] = mg.bgcolor;
}

static void
mg__frametrimcpy(uint32_t *dst, const uint32_t *src, size_t oldwidth, size_t newwidth,
		size_t oldstride, size_t newstride, size_t oldheight, size_t newheight)
{
	size_t roff = 0, woff = 0;
	size_t stride = MG__MIN(oldstride, newstride);
	size_t i = 0;
	for (; i < MG__MIN(oldheight, newheight) &&
			(roff < oldwidth * oldheight) &&
			(woff < newwidth * newheight); i++) {
		memcpy(dst + woff, src + roff, stride);
		roff += oldwidth;
		woff += newwidth;
	}
}

/*
 * -----------------------------------
 * internal functions: event handling utility
 */
static void
mg__fill_holder(struct mg__event_holder *holder, void *ev)
{
	if (!holder->gate || holder->gate(holder->gatedata, ev)) {
		holder->ev = ev;
		holder->waiting = 0;
	} else {
		free(ev);
	}
}

static int
mg__handle_wl_event(struct mg_event *event)
{
	struct mg__event_holder *holders[] = {
		mg.close_holder, mg.resize_holder, mg.kbd_holder, mg.pointer_holder
	};
	size_t i = 0;

	for (i = 0; i < 4; i++) {
		if (holders[i] && holders[i]->ev) {
			switch (i) {
			case 0:
				event->events |= MG_QUIT;
				break;
			case 1:
				event->events |= MG_RESIZE;
				break;
			case 2: { /* enter new scope to allow declaring var */
				struct mg__keyboard_event *kbd_ev = (struct mg__keyboard_event *)holders[i]->ev;
				uint32_t keycode = kbd_ev->key + 8; /* evdev -> xkb */
				if (kbd_ev->state == WL_KEYBOARD_KEY_STATE_PRESSED) {
					/* unlike X this isn't guaranteed to be <= 0xff so do a check */
					event->keydown = (keycode <= 0xff) ? mg.keycode_lookup[keycode] :
						MG_KEY_UNKNOWN;
					event->events |= MG_KEYDOWN;
				} else {
					event->keyup = (keycode <= 0xff) ? mg.keycode_lookup[keycode] :
						MG_KEY_UNKNOWN;
					event->events |= MG_KEYUP;
				}
				break; }
			case 3: { /* enter new scope to allow declaring var */
				struct mg__pointer_event *ptr_ev = (struct mg__pointer_event *)holders[i]->ev;
				switch (ptr_ev->type) {
				case MG__PTR_ENTER:
					event->mousemotion_x = wl_fixed_to_int(ptr_ev->data.enter.surface_x);
					event->mousemotion_y = wl_fixed_to_int(ptr_ev->data.enter.surface_y);
					event->events |= MG_MOUSEMOTION;
					break;
				case MG__PTR_MOTION:
					event->mousemotion_x = wl_fixed_to_int(ptr_ev->data.motion.surface_x);
					event->mousemotion_y = wl_fixed_to_int(ptr_ev->data.motion.surface_y);
					event->events |= MG_MOUSEMOTION;
					break;
				case MG__PTR_BUTTON: { /* enter new scope to allow declaring var */
					enum mg_mouse_btn button;
					switch (ptr_ev->data.button.button) {
					case BTN_LEFT:   button = MG_MOUSE_LEFT; break;
					case BTN_MIDDLE: button = MG_MOUSE_MIDDLE; break;
					case BTN_RIGHT:  button = MG_MOUSE_RIGHT; break;
					case BTN_SIDE:   button = MG_MOUSE_SIDE; break;
					case BTN_EXTRA:  button = MG_MOUSE_EXTRA; break;
					default:         button = MG_MOUSE_UNKNOWN; break;
					}
					if (ptr_ev->data.button.state == WL_POINTER_BUTTON_STATE_PRESSED) {
						event->mousedown = button;
						event->events |= MG_MOUSEDOWN;
					} else {
						event->mouseup = button;
						event->events |= MG_MOUSEUP;
					}
					break; }
				default:
					/* unreachable */
					break;
				}
				break; }
			}
			free(holders[i]->ev);
			holders[i]->ev = NULL;
			holders[i]->waiting = 1;
			return 1;
		}
	}
	return 0;
}

static uint32_t
mg__ms_until(const struct timespec *time)
{
        struct timespec now;
        clock_gettime(CLOCK_MONOTONIC, &now);

        if (now.tv_sec > time->tv_sec || (now.tv_sec == time->tv_sec && now.tv_nsec > time->tv_nsec))
                return 0;

        uint32_t sec = (uint32_t)(time->tv_sec - now.tv_sec);
        uint32_t nsec;
        if (now.tv_nsec > time->tv_nsec) {
                sec--;
                nsec = MG__NSEC - (uint32_t)(now.tv_nsec - time->tv_nsec);
        } else {
                nsec = (uint32_t)(time->tv_nsec - now.tv_nsec);
        }

        return sec * 1000 + nsec / 1000000;
}

/*
 * -----------------------------------
 * internal functions: shm
 */
static void
mg__randname(char *buf)
{
	/* generate a (pretty bad) random filename. */
	struct timespec tp;
	long r;
	int i = 0;
	clock_gettime(CLOCK_REALTIME, &tp);
	r = tp.tv_nsec;
	for (; i < 6; i++) {
		buf[i] = (char)('A'+(r&15)+(r&16)*2);
		r >>= 5;
	}
}

static int
mg__create_shm_file(void)
{
	int retries = 100;
	int fd;
	do {
		char name[] = "/mg-wl_shm-XXXXXX";
		mg__randname(name + sizeof(name) - 7);
		retries--;
		fd = shm_open(name, O_RDWR | O_CREAT | O_EXCL, 0600);
		if (fd >= 0) {
			shm_unlink(name);
			return fd;
		}
	} while (retries > 0 && errno == EEXIST);
	return -1;
}

static int
mg__allocate_shm_file(size_t size)
{
	int fd = mg__create_shm_file();
	int ret;
	if (fd < 0)
		MG__ERROR(MG_WL_SHM_ERROR)
	do {
		/*
		 * despite what it sounds like, ftruncate can
		 * actually increase the size of the file,
		 * that's what we're doing here
		 */
		ret = ftruncate(fd, (off_t)size);
	} while (ret < 0 && errno == EINTR);
	if (ret < 0) {
		mg_storederrno = errno;
		close(fd);
		MG__ERROR_NO_ERRNO(MG_WL_SHM_ERROR)
	}
	return fd;
}

/*
 * -----------------------------------
 * internal functions: wl_keyboard event listeners
 */
static void
mg__fill_keycode_lookup(struct mg__state *mg_state)
{
	xkb_keycode_t min = xkb_keymap_min_keycode(mg_state->xkb_keymap);
	xkb_keycode_t max = xkb_keymap_max_keycode(mg_state->xkb_keymap);
	size_t i;
	xkb_keycode_t code;
	const char *name;

	for (i = 0; i < sizeof(mg.keycode_lookup) / sizeof(mg.keycode_lookup[0]); i++)
		mg.keycode_lookup[i] = MG_KEY_UNKNOWN;
	for (code = min; code <= max && code <= 0xff; code++) {
		name = xkb_keymap_key_get_name(mg_state->xkb_keymap, code);
		if (!name || name[0] == '\0')
			continue;
		for (i = 0; i < sizeof(mg__xkb_name_key_lookup) / sizeof(mg__xkb_name_key_lookup[0]); i++)
			if (strncmp(mg__xkb_name_key_lookup[i].xkb_name, name, 4) == 0)
				mg.keycode_lookup[code] = mg__xkb_name_key_lookup[i].key;
	}
}

static void
mg__wl_keyboard_keymap(void *data, MG_UNUSED struct wl_keyboard *wl_keyboard, uint32_t format,
		int32_t fd, uint32_t size)
{
	struct mg__state *mg_state = (struct mg__state *)data;
	char *map_shm;

	if (format != WL_KEYBOARD_KEYMAP_FORMAT_XKB_V1) {
		close(fd);
		if (format == WL_KEYBOARD_KEYMAP_FORMAT_NO_KEYMAP)
			/*
			 * from my testing, my compositor sometimes sends this when
			 * the window comes back from being unfocused and not displayed
			 * don't error out
			 */
			return;
		/* future version that doesn't exist at the time of me writing this, bail */
		MG__ERROR(MG_WL_UNSUPPORTED_KEYMAP)
	}

	map_shm = mmap(NULL, size, PROT_READ, MAP_SHARED, fd, 0);
	close(fd);
	if (map_shm == MAP_FAILED)
		MG__ERROR(MG_OUT_OF_MEMORY) /* TODO: different type of error */

	/* configure the keymap */
	xkb_keymap_unref(mg_state->xkb_keymap);
	xkb_state_unref(mg_state->xkb_state);

	mg_state->xkb_keymap = xkb_keymap_new_from_string(mg_state->xkb_context, map_shm,
			XKB_KEYMAP_FORMAT_TEXT_V1, XKB_KEYMAP_COMPILE_NO_FLAGS);
	munmap(map_shm, size);
	if (!mg_state->xkb_keymap)
		MG__ERROR(MG_KEYBOARD_SETUP_FAILED)
	mg_state->xkb_state = xkb_state_new(mg_state->xkb_keymap);

	/* fill keycode lookup table */
	mg__fill_keycode_lookup(mg_state);
}

static void
mg__wl_keyboard_enter(MG_UNUSED void *data, MG_UNUSED struct wl_keyboard *wl_keyboard, MG_UNUSED uint32_t serial,
		MG_UNUSED struct wl_surface *surface, MG_UNUSED struct wl_array *keys)
{
	/* stub */
}

static void
mg__wl_keyboard_leave(MG_UNUSED void *data, MG_UNUSED struct wl_keyboard *wl_keyboard,
		MG_UNUSED uint32_t serial, MG_UNUSED struct wl_surface *surface)
{
	/* stub */
}

static void
mg__wl_keyboard_key(void *data, MG_UNUSED struct wl_keyboard *wl_keyboard, uint32_t serial,
		uint32_t time, uint32_t key, uint32_t state)
{
	struct mg__state *mg_state = (struct mg__state *)data;

	/* fill any active keyboard event holders */
	if (mg_state->kbd_holder && mg_state->kbd_holder->waiting) {
		struct mg__keyboard_event *ev = malloc(sizeof(struct mg__keyboard_event));
		if (!ev)
			MG__ERROR(MG_OUT_OF_MEMORY)

		ev->serial = serial;
		ev->time = time;
		ev->key = key;
		ev->state = state;
		mg__fill_holder(mg_state->kbd_holder, ev);
	}
}

static void
mg__wl_keyboard_modifiers(void *data, MG_UNUSED struct wl_keyboard *wl_keyboard,
		MG_UNUSED uint32_t serial, uint32_t mods_depressed, uint32_t mods_latched,
		uint32_t mods_locked, uint32_t group)
{
	struct mg__state *mg_state = (struct mg__state *)data;
	xkb_state_update_mask(mg_state->xkb_state, mods_depressed, mods_latched, mods_locked, 0, 0, group);
}

static void
mg__wl_keyboard_repeat_info(MG_UNUSED void *data, MG_UNUSED struct wl_keyboard *wl_keyboard,
		MG_UNUSED int32_t rate, MG_UNUSED int32_t delay)
{
	/* stub */
}

static const struct wl_keyboard_listener mg__wl_keyboard_listener = {
	.keymap      = mg__wl_keyboard_keymap,
	.enter       = mg__wl_keyboard_enter,
	.leave       = mg__wl_keyboard_leave,
	.key         = mg__wl_keyboard_key,
	.modifiers   = mg__wl_keyboard_modifiers,
	.repeat_info = mg__wl_keyboard_repeat_info
};

/*
 * -----------------------------------
 * internal functions: wl_pointer event listeners
 */
static void
mg__wl_pointer_enter(void *data, MG_UNUSED struct wl_pointer *wl_pointer, uint32_t serial,
		struct wl_surface *surface, wl_fixed_t surface_x, wl_fixed_t surface_y)
{
	struct mg__state *mg_state = (struct mg__state *)data;

	/* fill any active pointer event holders */
	if (mg_state->pointer_holder && mg_state->pointer_holder->waiting) {
		struct mg__pointer_event *ev = malloc(sizeof(struct mg__pointer_event));
		if (!ev)
			MG__ERROR(MG_OUT_OF_MEMORY)

		ev->type = MG__PTR_ENTER;
		ev->data.enter.serial = serial;
		ev->data.enter.surface = surface;
		ev->data.enter.surface_x = surface_x;
		ev->data.enter.surface_y = surface_y;
		mg__fill_holder(mg_state->pointer_holder, ev);
	}
}

static void
mg__wl_pointer_leave(void *data, MG_UNUSED struct wl_pointer *wl_pointer, uint32_t serial,
		struct wl_surface *surface)
{
	struct mg__state *mg_state = (struct mg__state *)data;

	/* fill any active pointer event holders */
	if (mg_state->pointer_holder && mg_state->pointer_holder->waiting) {
		struct mg__pointer_event *ev = malloc(sizeof(struct mg__pointer_event));
		if (!ev)
			MG__ERROR(MG_OUT_OF_MEMORY)

		ev->type = MG__PTR_LEAVE;
		ev->data.leave.serial = serial;
		ev->data.leave.surface = surface;
		mg__fill_holder(mg_state->pointer_holder, ev);
	}
}

static void
mg__wl_pointer_motion(void *data, MG_UNUSED struct wl_pointer *wl_pointer, uint32_t time,
		wl_fixed_t surface_x, wl_fixed_t surface_y)
{
	struct mg__state *mg_state = (struct mg__state *)data;

	/* fill any active pointer event holders */
	if (mg_state->pointer_holder && mg_state->pointer_holder->waiting) {
		struct mg__pointer_event *ev = malloc(sizeof(struct mg__pointer_event));
		if (!ev)
			MG__ERROR(MG_OUT_OF_MEMORY)

		ev->type = MG__PTR_MOTION;
		ev->data.motion.time = time;
		ev->data.motion.surface_x = surface_x;
		ev->data.motion.surface_y = surface_y;
		mg__fill_holder(mg_state->pointer_holder, ev);
	}
}

static void
mg__wl_pointer_button(void *data, MG_UNUSED struct wl_pointer *wl_pointer, uint32_t serial,
		uint32_t time, uint32_t button, uint32_t state)
{
	struct mg__state *mg_state = (struct mg__state *)data;

	/* fill any active pointer event holders */
	if (mg_state->pointer_holder && mg_state->pointer_holder->waiting) {
		struct mg__pointer_event *ev = malloc(sizeof(struct mg__pointer_event));
		if (!ev)
			MG__ERROR(MG_OUT_OF_MEMORY)

		ev->type = MG__PTR_BUTTON;
		ev->data.button.serial = serial;
		ev->data.button.time = time;
		ev->data.button.button = button;
		ev->data.button.state = state;
		mg__fill_holder(mg_state->pointer_holder, ev);
	}
}

static void
mg__wl_pointer_axis(void *data, MG_UNUSED struct wl_pointer *wl_pointer, uint32_t time,
		uint32_t axis, wl_fixed_t value)
{
	struct mg__state *mg_state = (struct mg__state *)data;

	/* fill any active pointer event holders */
	if (mg_state->pointer_holder && mg_state->pointer_holder->waiting) {
		struct mg__pointer_event *ev = malloc(sizeof(struct mg__pointer_event));
		if (!ev)
			MG__ERROR(MG_OUT_OF_MEMORY)

		ev->type = MG__PTR_AXIS;
		ev->data.axis.time = time;
		ev->data.axis.axis = axis;
		ev->data.axis.value = value;

		/*
		 * TODO: currently this entire function is completely useless
		 * cause our gate for the pointer holder always returns false
		 * for axis events since we don't have anywhere to put
		 * said axis events
		 */
		mg__fill_holder(mg_state->pointer_holder, ev);
	}
}

static void
mg__wl_pointer_frame(MG_UNUSED void *data, MG_UNUSED struct wl_pointer *wl_pointer)
{
	/* stub */
}

static void
mg__wl_pointer_axis_source(MG_UNUSED void *data, MG_UNUSED struct wl_pointer *wl_pointer, MG_UNUSED uint32_t axis_source)
{
	/* stub */
}

static void
mg__wl_pointer_axis_stop(MG_UNUSED void *data, MG_UNUSED struct wl_pointer *wl_pointer, MG_UNUSED uint32_t time,
		MG_UNUSED uint32_t axis)
{
	/* stub */
}

static void
mg__wl_pointer_axis_discrete(MG_UNUSED void *data, MG_UNUSED struct wl_pointer *wl_pointer, MG_UNUSED uint32_t axis,
		MG_UNUSED int32_t discrete)
{
	/* stub */
}

static const struct wl_pointer_listener mg__wl_pointer_listener = {
	.enter         = mg__wl_pointer_enter,
	.leave         = mg__wl_pointer_leave,
	.motion        = mg__wl_pointer_motion,
	.button        = mg__wl_pointer_button,
	.axis          = mg__wl_pointer_axis,
	.frame         = mg__wl_pointer_frame,
	.axis_source   = mg__wl_pointer_axis_source,
	.axis_stop     = mg__wl_pointer_axis_stop,
	.axis_discrete = mg__wl_pointer_axis_discrete
};

/*
 * -----------------------------------
 * internal functions: wl_buffer event listeners
 */
static void
mg__wl_buffer_release(MG_UNUSED void *data, struct wl_buffer *wl_buffer)
{
	/* sent by the compositor when it's no longer using this buffer */
	wl_buffer_destroy(wl_buffer);
}

static const struct wl_buffer_listener mg__wl_buffer_listener = {
	.release = mg__wl_buffer_release,
};

/*
 * -----------------------------------
 * internal functions: xdg_toplevel event listeners
 */
static struct wl_buffer *
mg__draw_frame(struct mg__state *mg_state)
{
	size_t stride = (size_t)mg_width * sizeof(uint32_t);
	size_t size = stride * (size_t)mg_height;

	int fd = mg__allocate_shm_file(size);
	uint32_t *data;
	struct wl_shm_pool *pool;
	struct wl_buffer *buffer;

	data = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
	if (data == MAP_FAILED) {
		close(fd);
		MG__ERROR(MG_OUT_OF_MEMORY)
	}

	/* create a wayland buffer object */
	pool = wl_shm_create_pool(mg_state->wl_shm, fd, (int32_t)size);
	buffer = wl_shm_pool_create_buffer(pool, 0, (int32_t)mg_width, (int32_t)mg_height,
			(int32_t)stride, WL_SHM_FORMAT_XRGB8888);
	wl_shm_pool_destroy(pool);
	close(fd);

	memcpy(data, mg_state->draw_buf, mg_state->buf_size);

	munmap(data, size);
	wl_buffer_add_listener(buffer, &mg__wl_buffer_listener, NULL);
	return buffer;
}

static void
mg__xdg_toplevel_configure(void *data, MG_UNUSED struct xdg_toplevel *xdg_toplevel,
		int32_t width, int32_t height, MG_UNUSED struct wl_array *states)
{
	struct mg__state *mg_state = (struct mg__state *)data;

	if (width == 0 || height == 0)
		/* compositor is deferring to us */
		return;

	if (width != (int32_t)mg_width || height != (int32_t)mg_height) {
		/* draw_buf needs resizing */
		size_t stride, size;
		uint32_t *new_draw_buf;

		mg_width = width;
		mg_height = height;
		stride = (size_t)mg_width * sizeof(uint32_t);
		size = stride * (size_t)mg_height;

		new_draw_buf = malloc(size);
		if (!new_draw_buf)
			MG__ERROR(MG_OUT_OF_MEMORY)
		mg__clear_buf(new_draw_buf, (size_t)mg_width, (size_t)mg_height);
		mg__frametrimcpy(new_draw_buf, mg_state->draw_buf,
			mg_state->buf_width, (size_t)mg_width,
			mg_state->buf_stride, stride,
			mg_state->buf_height, (size_t)mg_height);
		free(mg_state->draw_buf);
		mg_state->draw_buf = new_draw_buf;
		mg_state->buf_width = (size_t)mg_width;
		mg_state->buf_stride = stride;
		mg_state->buf_height = (size_t)mg_height;
		mg_state->buf_size = stride * (size_t)mg_height;

		/* fill any active resize event holders */
		if (mg_state->resize_holder && mg_state->resize_holder->waiting) {
			int *ev = malloc(sizeof(int));
			if (!ev)
				MG__ERROR(MG_OUT_OF_MEMORY)

			*ev = 1;
			mg__fill_holder(mg_state->resize_holder, ev);
		}
	}
}

static void
mg__xdg_toplevel_close(void *data, MG_UNUSED struct xdg_toplevel *toplevel)
{
	struct mg__state *mg_state = (struct mg__state *)data;

	/* fill any active close event holders */
	if (mg_state->close_holder && mg_state->close_holder->waiting) {
		int *ev = malloc(sizeof(int));
		if (!ev)
			MG__ERROR(MG_OUT_OF_MEMORY)

		*ev = 1;
		mg__fill_holder(mg_state->close_holder, ev);
	}
}

static const struct xdg_toplevel_listener mg__xdg_toplevel_listener = {
	.configure = mg__xdg_toplevel_configure,
	.close     = mg__xdg_toplevel_close
};

/*
 * -----------------------------------
 * internal functions: xdg_surface event listeners
 */
static void
mg__xdg_surface_configure(void *data, struct xdg_surface *xdg_surface, uint32_t serial)
{
	struct mg__state *mg_state = (struct mg__state *)data;
	struct wl_buffer *buffer;
	mg_state->configured++;
	xdg_surface_ack_configure(xdg_surface, serial);

	buffer = mg__draw_frame(mg_state);
	wl_surface_attach(mg_state->wl_surface, buffer, 0, 0);
	wl_surface_commit(mg_state->wl_surface);
}

static const struct xdg_surface_listener mg__xdg_surface_listener = {
	.configure = mg__xdg_surface_configure
};

/*
 * -----------------------------------
 * internal functions: xdg_wm_base event listeners
 */
static void
mg__xdg_wm_base_ping(MG_UNUSED void *data, struct xdg_wm_base *xdg_wm_base, uint32_t serial)
{
	xdg_wm_base_pong(xdg_wm_base, serial);
}

static const struct xdg_wm_base_listener mg__xdg_wm_base_listener = {
	.ping = mg__xdg_wm_base_ping
};

/*
 * -----------------------------------
 * internal functions: wl_seat event listeners
 */
static void
mg__wl_seat_capabilities(void *data, MG_UNUSED struct wl_seat *wl_seat, uint32_t capabilities)
{
	struct mg__state *mg_state = (struct mg__state *)data;
	int have_keyboard = capabilities & WL_SEAT_CAPABILITY_KEYBOARD;
	int have_pointer  = capabilities & WL_SEAT_CAPABILITY_POINTER;

	if (have_keyboard && !mg_state->wl_keyboard) {
		mg_state->wl_keyboard = wl_seat_get_keyboard(mg_state->wl_seat);
		wl_keyboard_add_listener(mg_state->wl_keyboard, &mg__wl_keyboard_listener, mg_state);
	} else if (!have_keyboard && mg_state->wl_keyboard) {
		wl_keyboard_release(mg_state->wl_keyboard);
		mg_state->wl_keyboard = NULL;
	}

	if (have_pointer && !mg_state->wl_pointer) {
		mg_state->wl_pointer = wl_seat_get_pointer(mg_state->wl_seat);
		wl_pointer_add_listener(mg_state->wl_pointer, &mg__wl_pointer_listener, mg_state);
	} else if (!have_pointer && mg_state->wl_pointer) {
		wl_pointer_release(mg_state->wl_pointer);
		mg_state->wl_pointer = NULL;
	}
}

static void
mg__wl_seat_name(MG_UNUSED void *data, MG_UNUSED struct wl_seat *wl_seat, MG_UNUSED const char *name)
{
	/* stub */
}

static const struct wl_seat_listener mg__wl_seat_listener = {
	.capabilities = mg__wl_seat_capabilities,
	.name         = mg__wl_seat_name
};

/*
 * -----------------------------------
 * internal functions: wl_registry event listeners
 */
static void
mg__wl_registry_global(void *data, struct wl_registry *wl_registry, uint32_t name,
		const char *interface, MG_UNUSED uint32_t version)
{
	struct mg__state *mg_state = (struct mg__state *)data;
	if (!strcmp(interface, wl_shm_interface.name)) {
		mg_state->wl_shm = wl_registry_bind(wl_registry, name, &wl_shm_interface, 1);
	} else if (!strcmp(interface, wl_compositor_interface.name)) {
		mg_state->wl_compositor = wl_registry_bind(wl_registry, name, &wl_compositor_interface, 4);
	} else if (!strcmp(interface, xdg_wm_base_interface.name)) {
		mg_state->xdg_wm_base = wl_registry_bind(wl_registry, name, &xdg_wm_base_interface, 1);
		xdg_wm_base_add_listener(mg_state->xdg_wm_base, &mg__xdg_wm_base_listener, mg_state);
	} else if (!strcmp(interface, wl_seat_interface.name)) {
		mg_state->wl_seat = wl_registry_bind(wl_registry, name, &wl_seat_interface, 7);
		wl_seat_add_listener(mg_state->wl_seat, &mg__wl_seat_listener, mg_state);
	}
}

static void
mg__wl_registry_global_remove(MG_UNUSED void *data, MG_UNUSED struct wl_registry *wl_registry,
		MG_UNUSED uint32_t name)
{
	/* stub */
}

static const struct wl_registry_listener wl_registry_listener = {
	.global        = mg__wl_registry_global,
	.global_remove = mg__wl_registry_global_remove
};

/*
 * -----------------------------------
 * internal functions: event holder gates
 */
static int
mg__pointer_holder_gate(MG_UNUSED void *gatedata, const void *ev)
{
	static const uint32_t accepted_buttons[] = {
		BTN_LEFT, BTN_MIDDLE, BTN_RIGHT, BTN_SIDE, BTN_EXTRA
	};
	const struct mg__pointer_event *ptr_ev = (const struct mg__pointer_event *)ev;

	if (ptr_ev->type == MG__PTR_LEAVE || ptr_ev->type == MG__PTR_AXIS)
		return 0;

	if (ptr_ev->type == MG__PTR_BUTTON) {
		size_t i = 0;
		int accepted = 0;
		for (; i < sizeof(accepted_buttons) / sizeof(accepted_buttons[0]); i++) {
			if (ptr_ev->data.button.button == accepted_buttons[i])
				accepted = 1;
		}
		if (!accepted)
			return 0;
	}

	return 1;
}

/*
 * -----------------------------------
 * public API functions: initialization, shutdown, errors
 */
void
mg_init(int w, int h, const char *title, jmp_buf err_return)
{
	*mg.err_return = *err_return;

	/* assign some sentinel values before the first possibility of an error */
	mg.wl_surface = NULL;
	mg.xdg_surface = NULL;
	mg.xdg_toplevel = NULL;
	mg.xdg_wm_base = NULL;
	mg.wl_display = NULL;

	/* clear internal state */
	mg_width = w;
	mg_height = h;

	mg.configured = 0;
	mg.bgcolor = 0xffffff;
	mg.buf_width = (size_t)mg_width;
	mg.buf_height = (size_t)mg_height;
	mg.buf_stride = mg.buf_width * sizeof(uint32_t);
	mg.buf_size = mg.buf_stride * mg.buf_height;

	mg.draw_buf = malloc(mg.buf_size);
	if (!mg.draw_buf)
		MG__ERROR(MG_OUT_OF_MEMORY)
	mg_clear();

	/* set up event holders */
	mg.close_holder = malloc(sizeof(struct mg__event_holder));
	mg.resize_holder = malloc(sizeof(struct mg__event_holder));
	mg.kbd_holder = malloc(sizeof(struct mg__event_holder));
	mg.pointer_holder = malloc(sizeof(struct mg__event_holder));
	if (!mg.close_holder || !mg.resize_holder || !mg.kbd_holder || !mg.pointer_holder)
		MG__ERROR(MG_OUT_OF_MEMORY)

	mg.close_holder->gate = mg.resize_holder->gate = mg.kbd_holder->gate = NULL;
	mg.pointer_holder->gate = mg__pointer_holder_gate;
	mg.pointer_holder->gatedata = NULL;
	mg.close_holder->ev = mg.resize_holder->ev = mg.kbd_holder->ev = mg.pointer_holder->ev = NULL;
	mg.close_holder->waiting = mg.resize_holder->waiting = mg.kbd_holder->waiting = mg.pointer_holder->waiting = 1;

	/* connect to wl display */
	mg.wl_display = wl_display_connect(NULL);
	if (!mg.wl_display)
		MG__ERROR(MG_CONNECTION_FAILED)

	/* set up wayland components */
	mg.wl_registry = wl_display_get_registry(mg.wl_display);
	mg.xkb_context = xkb_context_new(XKB_CONTEXT_NO_FLAGS);
	wl_registry_add_listener(mg.wl_registry, &wl_registry_listener, &mg);
	wl_display_roundtrip(mg.wl_display);

	mg.wl_surface = wl_compositor_create_surface(mg.wl_compositor);
	mg.xdg_surface = xdg_wm_base_get_xdg_surface(mg.xdg_wm_base, mg.wl_surface);
	xdg_surface_add_listener(mg.xdg_surface, &mg__xdg_surface_listener, &mg);
	mg.xdg_toplevel = xdg_surface_get_toplevel(mg.xdg_surface);
	xdg_toplevel_add_listener(mg.xdg_toplevel, &mg__xdg_toplevel_listener, &mg);
	xdg_toplevel_set_title(mg.xdg_toplevel, title);
	wl_surface_commit(mg.wl_surface);

	/* wait for xdg_surface to get configured */
	while (mg.configured < 2)
		wl_display_dispatch(mg.wl_display);
}

void
mg_fullscreen(int enable)
{
	if (enable)
		xdg_toplevel_set_fullscreen(mg.xdg_toplevel, NULL);
	else
		xdg_toplevel_unset_fullscreen(mg.xdg_toplevel);
}

void
mg_set_title(const char *title)
{
	xdg_toplevel_set_title(mg.xdg_toplevel, title);
}

const char *
mg_errstring(void)
{
	static char buf[MG__ERRSTRING_BUFSIZE];
	size_t l = MG__MIN(strlen(mg__strerrors[mg_errstatus]), MG__ERRSTRING_BUFSIZE - 1);

	memcpy(buf, mg__strerrors[mg_errstatus], l);
	buf[l] = '\0';
	if (mg_errstatus == MG_IO_ERROR || mg_errstatus == MG_WL_PROTOCOL_OR_IO_ERROR || mg_errstatus == MG_WL_SHM_ERROR) {
		const char *e = strerror(mg_storederrno);
		size_t l2 = MG__MIN(strlen(e), MG__ERRSTRING_BUFSIZE - l - 1);
		memcpy(buf + l, e, l2);
		buf[l + l2] = '\0';
	}
	return buf;
}

void
mg_quit(void)
{
	struct mg__event_holder *holders[] = {
		mg.close_holder, mg.resize_holder, mg.kbd_holder, mg.pointer_holder
	};
	size_t i = 0;

	/* destroy wayland components */
	if (mg.wl_surface) {
		wl_surface_attach(mg.wl_surface, NULL, 0, 0);
		wl_surface_commit(mg.wl_surface);
		wl_surface_destroy(mg.wl_surface);
	}
	if (mg.xdg_surface)
		xdg_surface_destroy(mg.xdg_surface);
	if (mg.xdg_toplevel)
		xdg_toplevel_destroy(mg.xdg_toplevel);
	if (mg.xdg_wm_base)
		xdg_wm_base_destroy(mg.xdg_wm_base);

	/* disconnect from wl display */
	if (mg.wl_display)
		wl_display_disconnect(mg.wl_display);

	/* free internal data structures */
	free(mg.draw_buf); /* free(NULL) is a no-op */

	for (i = 0; i < 4; i++) {
		if (holders[i]) {
			free(holders[i]->ev); /* free(NULL) is a no-op */
			free(holders[i]);
		}
	}
}

/*
 * -----------------------------------
 * public API functions: events
 */
int
mg_getevent(struct mg_event *event)
{
	struct pollfd pfd;

	/* drain current queue without blocking */
	int ret = wl_display_dispatch_pending(mg.wl_display);
	if (ret < 0)
		MG__ERROR(MG_WL_PROTOCOL_OR_IO_ERROR)
	if (ret > 0)
		return mg__handle_wl_event(event);

	/* try to wl_display_prepare_read() until we succeed */
	while (wl_display_prepare_read(mg.wl_display) < 0) {
		/* queue wasn't empty */
		ret = wl_display_dispatch_pending(mg.wl_display);
		if (ret < 0)
			MG__ERROR(MG_WL_PROTOCOL_OR_IO_ERROR)
		if (ret > 0)
			return mg__handle_wl_event(event);
	}

	/* flush buffered data */

	/*
	 * check for EWOULDBLOCK in case on this platform
	 * EAGAIN != EWOULDBLOCK and write/sendmsg may set EWOULDBLOCK
	 */
	if (wl_display_flush(mg.wl_display) < 0 && errno != EAGAIN && errno != EWOULDBLOCK) {
		wl_display_cancel_read(mg.wl_display);
		MG__ERROR(MG_IO_ERROR)
	}

	/* poke wl_display */
	pfd.fd = wl_display_get_fd(mg.wl_display);
	pfd.events = POLLIN;
	ret = poll(&pfd, 1, 0);

	if (ret < 0) {
		wl_display_cancel_read(mg.wl_display);
		if (errno == EINTR)
			/* we don't wanna block so just treat this as no events available */
			return 0;
		MG__ERROR(MG_IO_ERROR)
	}

	if (ret > 0 && (pfd.revents & POLLIN)) {
		/* we've got stuff to read, queue it */
		if (wl_display_read_events(mg.wl_display) < 0)
			MG__ERROR(MG_WL_PROTOCOL_OR_IO_ERROR)

		/* dispatch newly queued events */
		ret = wl_display_dispatch_pending(mg.wl_display);
		if (ret < 0)
			MG__ERROR(MG_WL_PROTOCOL_OR_IO_ERROR)

		return mg__handle_wl_event(event);
	} else {
		/* either nothing to read or error */
		wl_display_cancel_read(mg.wl_display);
		if (ret > 0 && (pfd.revents & (POLLERR | POLLHUP | POLLNVAL)))
			MG__ERROR(MG_IO_ERROR);
		return 0;
	}
}

void
mg_waitevent(struct mg_event *event)
{
	for (;;) {
		/* wait for a wayland event to happen */
		if (wl_display_dispatch(mg.wl_display) < 0) {
			if (errno == EINTR)
				continue;
			MG__ERROR(MG_WL_PROTOCOL_OR_IO_ERROR)
		}

		/* handle event */
		if (mg__handle_wl_event(event))
			break;
	}
}

int
mg_waiteventfor(struct mg_event *event, int ms)
{
	struct timespec timeout;
	struct pollfd pfd;

	uint32_t rem;
	int ret;

	if (ms == 0)
		return mg_getevent(event);

	/* maybe there's something queued & we don't even have to block? */
	ret = wl_display_dispatch_pending(mg.wl_display);
	if (ret < 0)
		MG__ERROR(MG_WL_PROTOCOL_OR_IO_ERROR)
	if (ret > 0 && mg__handle_wl_event(event))
		return 1;

	/* nope, set our deadline then */
	clock_gettime(CLOCK_MONOTONIC, &timeout);
	timeout.tv_sec  += ms / 1000;
	timeout.tv_nsec += (ms % 1000) * 1000000;
	if (timeout.tv_nsec >= MG__NSEC) {
		timeout.tv_nsec -= MG__NSEC;
		timeout.tv_sec++;
	}

	pfd.fd = wl_display_get_fd(mg.wl_display);
	for (;;) {
		/* try to wl_display_prepare_read() until we succeed */
		while (wl_display_prepare_read(mg.wl_display) < 0) {
			/* queue wasn't empty */
			ret = wl_display_dispatch_pending(mg.wl_display);
			if (ret < 0)
				MG__ERROR(MG_WL_PROTOCOL_OR_IO_ERROR)
			if (ret > 0 && mg__handle_wl_event(event))
				return 1;
		}

		/* flush buffered data */
		pfd.events = POLLIN;
		if (wl_display_flush(mg.wl_display) < 0) {
			/*
			 * check for EWOULDBLOCK in case on this platform
			 * EAGAIN != EWOULDBLOCK and write/sendmsg may set EWOULDBLOCK
			 */
			if (errno == EAGAIN || errno == EWOULDBLOCK) {
				/*
				 * "...if all data could not be written, errno will be
				 * set to EAGAIN and -1 returned. In that case, use
				 * poll on the display file descriptor to wait for it
				 * to become writable again."
				 *
				 * https://wayland.freedesktop.org/docs/html/apb.html
				 */
				pfd.events |= POLLOUT;
			} else {
				wl_display_cancel_read(mg.wl_display);
				MG__ERROR(MG_IO_ERROR)
			}
		}

		/* poll for events with remaining time */
		do {
			/* calculate remaining time */
			rem = mg__ms_until(&timeout);
			if (rem == 0) {
				/* out of time */
				wl_display_cancel_read(mg.wl_display);
				return 0;
			}
			/* clamp just in case */
			ret = poll(&pfd, 1, rem <= INT_MAX ? rem : INT_MAX);
		} while (ret < 0 && errno == EINTR);
		if (ret < 0) {
			wl_display_cancel_read(mg.wl_display);
			MG__ERROR(MG_IO_ERROR)
		}

		if (ret > 0 && (pfd.revents & POLLIN)) {
			/* we've got stuff to read, queue it */
			if (wl_display_read_events(mg.wl_display) < 0)
				MG__ERROR(MG_WL_PROTOCOL_OR_IO_ERROR)

			/* dispatch newly queued events */
			ret = wl_display_dispatch_pending(mg.wl_display);
			if (ret < 0)
				MG__ERROR(MG_WL_PROTOCOL_OR_IO_ERROR)
			if (ret > 0 && mg__handle_wl_event(event))
				return 1;
		} else {
			/* either only POLLOUT, nothing to read, or error */
			wl_display_cancel_read(mg.wl_display);
			if (ret == 0) /* nothing to read (timed out) */
				return 0;
			else if (ret > 0 && (pfd.revents & (POLLERR | POLLHUP | POLLNVAL)))
				MG__ERROR(MG_IO_ERROR);
			/* else: only POLLOUT, just retry */
		}

		/* check if we still have time */
		rem = mg__ms_until(&timeout);
		if (rem == 0)
			return 0;
	}
	return 0; /* should be unreachable */
}

/*
 * -----------------------------------
 * public API functions: drawing
 */
void
mg_clear(void)
{
	mg__clear_buf(mg.draw_buf, mg.buf_width, mg.buf_height);
}

void
mg_draw(const uint32_t *data, uint32_t width, uint32_t height,
		enum mg_pixel_format pixel_format, int x, int y)
{
	if (x < (int)mg.buf_width && y < (int)mg.buf_height) {
		size_t i = 0; /* position in buffer */
		int dx, dy = 0; /* x offset / y offset to draw at */
		for (; dy < (int)height; dy++) {
			for (dx = 0; dx < (int)width; dx++) {
				if ((dx + x) >= 0 && (dy + y) >= 0 && (dx + x) < (int)mg.buf_width &&
						(dy + y) < (int)mg.buf_height) {
					/* remember we're using XRGB */
					switch (pixel_format) {
					case MG_PIXEL_FORMAT_RGBX:
						mg.draw_buf[(dy + y) * (int)mg.buf_width + (dx + x)] =
							data[i] >> 8;
						break;
					case MG_PIXEL_FORMAT_BGRX:
						mg.draw_buf[(dy + y) * (int)mg.buf_width + (dx + x)] =
							((data[i] & 0xff000000) >> 24) |
							((data[i] & 0x00ff0000) >> 8) |
							((data[i] & 0x0000ff00) << 8);
						break;
					case MG_PIXEL_FORMAT_XRGB:
						mg.draw_buf[(dy + y) * (int)mg.buf_width + (dx + x)] =
							data[i];
						break;
					case MG_PIXEL_FORMAT_XBGR:
						mg.draw_buf[(dy + y) * (int)mg.buf_width + (dx + x)] =
							((data[i] & 0x00ff0000) >> 16) |
							( data[i] & 0x0000ff00) |
							((data[i] & 0x000000ff) << 16);
						break;
					case MG_PIXEL_FORMAT_256:
						mg.draw_buf[(dy + y) * (int)mg.buf_width + (dx + x)] =
							mg__256_palette[((uint8_t *)(data))[i]];
						break;
					}
				}
				i++;
			}
		}
	}
}

void
mg_flush(void)
{
	/* submit a frame for this event */
	struct wl_buffer *buffer = mg__draw_frame(&mg);
	wl_surface_attach(mg.wl_surface, buffer, 0, 0);
	wl_surface_damage_buffer(mg.wl_surface, 0, 0, INT32_MAX, INT32_MAX);
	wl_surface_commit(mg.wl_surface);
}

void
mg_setbgcolor(uint8_t r, uint8_t g, uint8_t b)
{
	/* remember we're using XRGB */
	mg.bgcolor = (uint32_t)((r << 16) | (g << 8) | b);
}
#endif /* defined(MG_BACKEND_WAYLAND) */

#endif /* MG_IMPLEMENTATION */

/*
 * this library is available under 2 licenses - choose whichever you prefer.
 *
 * ---------------------------------------------------------------------------
 * ALTERNATIVE A - Unlicense
 *
 * This is free and unencumbered software released into the public domain.
 *
 * Anyone is free to copy, modify, publish, use, compile, sell, or
 * distribute this software, either in source code form or as a compiled
 * binary, for any purpose, commercial or non-commercial, and by any
 * means.
 *
 * In jurisdictions that recognize copyright laws, the author or authors
 * of this software dedicate any and all copyright interest in the
 * software to the public domain. We make this dedication for the benefit
 * of the public at large and to the detriment of our heirs and
 * successors. We intend this dedication to be an overt act of
 * relinquishment in perpetuity of all present and future rights to this
 * software under copyright law.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * For more information, please refer to <http://unlicense.org/>
 *
 * ---------------------------------------------------------------------------
 * ALTERNATIVE B - MIT/X Consortium License
 *
 * Copyright (c) 2025 slightlyeepy
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
